<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://tiltcat.com">
  <title>从PAXOS到ZOOKEEPER分布式一致性原理与实践. | Let&#39;s do this</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="要搞互联网，分布式的，zookeeper挺重要的，但是问题在于目前我几乎什么都不知道，有人推荐了这么一本书，现在还没有系统的总结，就当做学习笔记用吧！">
<meta property="og:type" content="article">
<meta property="og:title" content="从PAXOS到ZOOKEEPER分布式一致性原理与实践.">
<meta property="og:url" content="http://tiltcat.com/2017/03/24/从PAXOS到ZOOKEEPER分布式一致性原理与实践/index.html">
<meta property="og:site_name" content="Let's do this">
<meta property="og:description" content="要搞互联网，分布式的，zookeeper挺重要的，但是问题在于目前我几乎什么都不知道，有人推荐了这么一本书，现在还没有系统的总结，就当做学习笔记用吧！">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/zookeeper.png">
<meta property="og:updated_time" content="2017-04-01T07:54:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从PAXOS到ZOOKEEPER分布式一致性原理与实践.">
<meta name="twitter:description" content="要搞互联网，分布式的，zookeeper挺重要的，但是问题在于目前我几乎什么都不知道，有人推荐了这么一本书，现在还没有系统的总结，就当做学习笔记用吧！">
<meta name="twitter:image" content="http://ogeojkg3t.bkt.clouddn.com/zookeeper.png">
  
  
    <link rel="icon" href="/images/favicon.jpg">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">tiltcat</a></h1>
		</hgroup>

		
		<p class="header-subtitle">wub lab dup dup</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/felisnigreps" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/cool5231" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tilt-play" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">tiltcat</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/avatar.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">tiltcat</h1>
			</hgroup>
			
			<p class="header-subtitle">wub lab dup dup</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/felisnigreps" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/cool5231" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tilt-play" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-从PAXOS到ZOOKEEPER分布式一致性原理与实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      从PAXOS到ZOOKEEPER分布式一致性原理与实践.
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要搞互联网，分布式的，zookeeper挺重要的，但是问题在于目前我几乎什么都不知道，有人推荐了这么一本书，现在还没有系统的总结，就当做学习笔记用吧！</p>
<a id="more"></a>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>CAP定理（和我现在公司的名字一样…）说的是分布式的三个特点，一致性，可用性和分区容错性。</p>
<p><code>一致性</code>：数据在多个副本之间是否能保持一致的特性。当一个系统在数据一致的状态下执行更新操作以后，应该保证系统的数据依然处于一致的状态。</p>
<p><code>可用性</code>：它是指系统的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。其中有两点需要我们注意，有限时间和返回结果。所谓的有限时间是用户定义的一个时间，在不同的场景下会有不同的指标，就是我们所说的合理的响应时间。比如说搜索引擎是0.5s，某些大数据的检索也许在20s左右。但是如果当用户输入一个关键字，系统返回的是一个错误，比如OutOfMemory等，那么我们就可以说这个系统是不可用的。</p>
<p><code>分区容错性</code>：所谓分区容错性指的是当分布式系统遇到任何网络分区发生故障的时候，仍然需要对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<p>CAP理论代表的是，一个分布性系统不可能同时满足以上的三个基本需求，最多只能满足其中的两项，感兴趣的同学可以自行查阅相关资料。</p>
<p>我们刚提到三项不可同时满足，那么在进行CAP定理的应用时，我们就需要抛弃其中一项。<br>但是我们创建分布式系统的初衷就是需要满足分区容错性，因为分布式系统肯定要分布在不同的节点上，如果不能满足分区容错性，那么我们还用什么分布式呢？所以现在的问题就变成了我们要选择则A(可用性)还是C(一致性)。</p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE是指，basically avaiable,soft state和Eventually consistent三个短语的缩写，但标的就是：基本可用，软状态和最终一致性。</p>
<h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>它指的是分布式系统在出现不可预知故障的时候，允许损失部分可用性，所谓部分可用性，可以参考以下两个例子：<br>1.响应时间的损失：正常情况下一个搜索引擎需要0.5s内给用户返回结果，但是由于出现故障（比如断电或者断网），查询结果的响应时间增加到1~2s.</p>
<p>2.功能上的损失：正常情况下，在一个电子网站上进行购物， 消费者几乎都可以顺利完成订单，但是在促销的高峰期，访问量大大增加，为了保护系统的文明行，部分的消费者可能会被引导到一个降级界面。</p>
<h3 id="弱状态"><a href="#弱状态" class="headerlink" title="弱状态"></a>弱状态</h3><p>也被成为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。所以最终一致性的本质是需要系统保证数据最终能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>最终一致性是一种特殊的弱一致性：系统能够保证在没有其他新的更新操作状况下，数据最终能够达到一个一致的状态，因为所有客户端对系统的数据访问都能获取到最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟取决于网络延迟，系统负载等设计因素。</p>
<p>最终一致性在实际的应用中存在以下五个主要变种：</p>
<p>1.因果一致性:如果进程A在更新完某个数据后通知了进程B,那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值。嗯…happens before.<br>2.读已之所写：总是可以读到自己的更新，嗯，还是happens before.<br>3.会话一致性：个人理解就是结合了前两点，在一个会话中客户总是可以读取到最新值。<br>4.单调读一致性：还是happens before<br>5.单调写一致性：还是happens before</p>
<p>感觉没什么东西，就是happens before.</p>
<p>总体来说，BASE理论面向的是大型可用可扩展的分布式系统，和传统的ACID强一致性模型是相反的，他完全不同于ACID，通过牺牲强一致性来获得可用性，允许数据在一段时间内是不一致的，但会达到最终一致状态。但同时，在实际的场景中，不同业务要求的一致性又是不一致的，因此ACID和BASE往往会结合在一起使用。</p>
<h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><p>为了解决我们上述提到的一致性问题，出现了一些经典的协议，下面介绍二阶段提交协议，三阶段提交协议和Paxos算法。</p>
<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>二阶段协议，two phase commit的缩写，即为二阶段提交，是计算机网络尤其是数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中保持一致性的一种算法。目前绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便的完成事务的协调，同意决定事务的提交和回滚，从而高效的保证分布式数据一致性。</p>
<h3 id="阶段一：提交事务请求"><a href="#阶段一：提交事务请求" class="headerlink" title="阶段一：提交事务请求"></a>阶段一：提交事务请求</h3><p>角色：协调者（a），参与者们(b)</p>
<p>1.事务询问：a向b发送事务内容，并且询问是否可以进行提交，等待相应。<br>2.执行事务：b执行事务，并且将Undo和Redo信息记录与事务日志中。</p>
<blockquote>
<p>Undo日志记录某数据被修改前的值，可以用来在事务失败时进行rollback；Redo日志记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。<br>例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为<t1, 5="" x,="">，Redo日志为<t1, 15="" x,="">。<br>也有把undo和redo结合起来的做法，叫做Undo/Redo日志，在这个例子中Undo/Redo日志为<t1, 15="" x,="" 5,="">。</t1,></t1,></t1,></p>
</blockquote>
<p>3.b向a发送反馈，成功执行了事务发送Yes响应，失败发送No响应。</p>
<p>此阶段叶恒做投票阶段，a会根据b的反馈来进行决定。</p>
<h3 id="阶段二：执行事务提交"><a href="#阶段二：执行事务提交" class="headerlink" title="阶段二：执行事务提交"></a>阶段二：执行事务提交</h3><p>在此阶段，a会根据b的响应来决定是否可以进行提交操作，一般情况下包含以下两种可能：</p>
<h4 id="执行事务提交"><a href="#执行事务提交" class="headerlink" title="执行事务提交"></a>执行事务提交</h4><p>如果返回的都是Yes,那么a会向b发送commit请求–&gt;b接收到了commit请求后，会进行提交擦操作，在完成后释放资源–&gt;b完成提交后向a发送Ack消息（响应）–&gt;a接收到ack消息后，完成事务。</p>
<h4 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h4><p>如果任何一个b返回了No响应或者等待超时之后，那么a就会中断事务，向所有节点发出Rollback请求–&gt;参与者接收到rollback请求后，会用Undo信息来进行回滚操作。并且在回滚之后释放资源，向a发送Ack消息–&gt;a接收到所有参与者 Ack消息后完成事务中断。</p>
<p>这个协议理解起来很简单，但是也存在以下缺点：</p>
<p>同步阻塞：参与者在等待响应中无法进行其他操作<br>单点问题：a在整个过程中起到了很重要的作用，几乎是单一实效点，而且如果在阶段二a出现了问题，那么其他参与者会一直处于锁定资源的状态中<br>数据不一致：在阶段二中a向b发送了commit请求，在期间自身或者网络发生问题，那么只会有一部分b接收到请求，这就造成了数据不一致性。<br>太过保守：没有设置比较完善的容错机制，任意一个节点的失败都会导致整个事物的失败。</p>
<h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p>三阶段提交协议是在二阶段的基础上进行了改进，将二阶段的<code>提交事务请求</code>一分为二，形成了CanCommit,PreCommit和do Commit三个阶段组成的事务处理协议。</p>
<h3 id="阶段一-CanCommit"><a href="#阶段一-CanCommit" class="headerlink" title="阶段一:CanCommit"></a>阶段一:CanCommit</h3><p>1.事物询问<br>a向b发送一个包含事物内容的canCommit请求，询问是否可以执行事物提交操作，并等待响应。<br>3.b向a反馈事物询问<br>b接收到canCommit请求后，如果其自身认为可以顺利执行，那么就反馈Yes响应，反之反馈No.</p>
<h3 id="阶段二：PreCommit"><a href="#阶段二：PreCommit" class="headerlink" title="阶段二：PreCommit"></a>阶段二：PreCommit</h3><h4 id="执行事务预提交"><a href="#执行事务预提交" class="headerlink" title="执行事务预提交"></a>执行事务预提交</h4><p>假设a从b中获得的都是Yes响应，那么就会执行事务预提交。<br>a向所有b发送precommit请求，进入prepared阶段–&gt;b接收到preCommit请求后，会执行任务操作，记录undo和redo信息到日志中–&gt;如果b成功的执行了事务操作，那么就会反馈给aAck响应，同时等待最终的指令，提交或者中止</p>
<h4 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h4><p>如果任何一个b反馈了No响应或者a等待超时，那么a就会像所有的b发送中断请求–&gt;无论b是接到中断请求或者等待超时，b都会中断事务</p>
<h3 id="阶段三：doCommit"><a href="#阶段三：doCommit" class="headerlink" title="阶段三：doCommit"></a>阶段三：doCommit</h3><p>该阶段进行真正的事物提交，有以下两种情况</p>
<h4 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h4><p>假设a处于正常工作状态，并且接收到了所有b的Ack响应，那么他会从预提交转变为提交状态，并且向所有b发送doCommit请求–&gt;b接收到doCommit请求后，会执行事务的提交操作，释放资源，向a发送Ack消息–&gt;a接收到Ack之后完成后事务</p>
<h4 id="中断事务-2"><a href="#中断事务-2" class="headerlink" title="中断事务"></a>中断事务</h4><p>假设a正常工作，并且任意一个b返回了No或者等待超时，那么就会中断事务，向所有b发送abort请求–&gt;b接收到abort请求后，会利用undo日志来进行回滚，释放资源，向a发送Ack消息–&gt;a接收到Ack消息后中断事务</p>
<p>在阶段三可能会出现下面两种故障，a出现问题或者ab之间的网络出现问题。这两种情况都会导致b无法接收到a的doCommit或者abort请求，针对这样的情况b都会在等待超时之后继续进行事务的提交。</p>
<p>相对于2PC，3PC最大的优点就是降低了b的阻塞范围，当出现单点故障后可以继续打达成一致。不过问题还是多多，传输的过程中依旧会出现问题。</p>
<p>简单说下，3PC将2PC的第二步分为两步，2PC是a直接给b发送提交信号，然后b就提交，然后反馈。3PC是把commit分为preCommit和doCommit,a先给b发送preCommit信号，b接到了说ok，我准备好了，然后a在发送doCommit信号。</p>
<h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p>Paxos是Leslie Lamport在1990年提出的分布式一致性协议，是目前公认的解决分布式一致性问题最有效的算法之一。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法需要保证以下几点：<br>（这里的提案可以被理解为请求，比如说proposer申请一个数据的提交）</p>
<blockquote>
<ul>
<li>这些提案中，只会有一个被选定</li>
<li>如果没有提案被提出，那么就不会有被选定提案</li>
<li>当一个提案被选定后，进程应该可以获取被选定的提案信息</li>
</ul>
</blockquote>
<p>对于一致性来说，安全性需求如下：</p>
<blockquote>
<ul>
<li>只有被提出提案才能被选定</li>
<li>只有一个值被选定</li>
<li>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个</li>
</ul>
</blockquote>
<p>Paxos算法的目标就是要保证最终有一个提案被选定，当提案被选定后，进程最终也能获取到被选定的提案。<br><code>P,A,L代表三个角色的缩写</code><br>在该一致性算法中，Paxos中存在三种角色Proposer（提议者）、Acceptor（决策者）、Learner（议案学习者）。在具体的实现中，一个进程可能充当不止一个角色，在这里我们并不关心进程如何映射到各种角色，假设各个参与者之间可以通过首发消息来进行通讯，那么：</p>
<blockquote>
<ul>
<li>每个参与者在执行的过程中都可能出错而停止，也可能会重启。同时，及时一个提案被选定后，所有参与作者也都有可能失败或者重启，因此那些失败或者重启的参与者必须可以记录某些信息，不然没有办法确定最终的值</li>
<li>消息在传输过程中可能出现不可预知的延迟，也可能会重复或者丢失，但是消息内容不会被篡改。</li>
</ul>
</blockquote>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><h4 id="最简单的方案-只有一个acceptor"><a href="#最简单的方案-只有一个acceptor" class="headerlink" title="最简单的方案-只有一个acceptor"></a>最简单的方案-只有一个acceptor</h4><p>假设只有一个acceptor，那么它只要接受第一个提案，把它当做value,那么就可以保证上述条件。但是，但是，单点失效，所以，并不行。</p>
<h4 id="多个acceptor"><a href="#多个acceptor" class="headerlink" title="多个acceptor"></a>多个acceptor</h4><p>首先，我们希望即使只有一个P提出了value,那么该value也会被选定，就得出了我们的第一个约束P1：<code>一个A必须接受他收到的第一个提案</code>(一个A可以接受多个提案)<br>但是如果每个proposer提出不同的value给不同的A，那就出现了不一致的value,这当然是不行的，所以我们新加了一个规定：<code>一个提案被选定需要被半数以上的A接受</code><br>这就表明，一个A要接收多个value,不然会出现没办法选定value的情况（三个P给三个A提交不同的Value）<br>那么怎么区分value呢？那么提案就不能是简简单单的value了，我们的提案=id+value.这里的id是uid,根据顺序自增长,实现过程先不讨论。<br>有了id之后，那么又有了以下的约束P2：<code>如果某个value=v的提案被选定了，那么每个id更高的被选定的提案的value必须也是v</code><br>一个提案只有被A接受才会被选定，所以调换一下主语，得到了P2a:<code>如果某个value=v的提案被选定了，那么每个编号更高的被A接受的提案的value必须也是v</code>，满足了P2a,就满足了P2.</p>
<p>但是考虑一下这种情况，有5个P,5个A,P2提出了[m1,v1]的提案，半数以上的A接受了该提案，那么v1就被选定了。这时候A1从宕机中恢复过来，恰巧P1又向A1发送了[m2,p2]提案，这是A1接收到的第一个提案，那么他会接受这个提案，好了，不一致就出现了。同时也违背了P2a约束。</p>
<p>所以我们需要对P2a进行进一步的修改，这就是我们的P2b:<code>如果某个value=v的提案被选定了，那么之后任何P提出的编号更高的提案的value也必须是v</code>。</p>
<p>那么如何确保在某个value=v的提案被选定后，P提出的编号更高的提案的value都是v呢？（上面的例子就不是）让我们看看P2c:<code>对于任意的n和v，如果[n,v]被提出，那么存在一个半数以上的A组成的集合S,满足以下两个条件的任意一个：</code></p>
<blockquote>
<ul>
<li>S中每个A都没有接受过编号小鱼N的提案</li>
<li>S中A接受过的最大编号的提案value=v</li>
</ul>
</blockquote>
<p>这只是另外一个约束，那么那么那么问题来了，就还说上面的那个情况，怎么避免呢？</p>
<h4 id="Proposer生成提案"><a href="#Proposer生成提案" class="headerlink" title="Proposer生成提案"></a>Proposer生成提案</h4><p>为了满足P2b，这里有个比较重要的思想：P生成提案之前，应该先去学习已经被选定或者可能被选定的value,然后以该value作为自己提出提案的value。如果没有value被选定，P才可以决定自己的value值。这样才能达成一致，这个学校的阶段是通过一个<code>prepare请求</code>实现的。</p>
<p>p首先发送给a编号m，a确认了编号有效（大于现存编号），那么反馈给p accept,然后p发送提案[m,n]</p>
<p>于是我们得到了<code>提案生成算法</code>:</p>
<p>1.P选择一个新的提案编号N,然后向某个A集合（半数以上）发送请求，要求集合中每个A作出以下响应。<br>a.向P承诺不再接受任何编号小于N的提案<br>b.如果A已经接受过提案，那么就像P响应已经接受过的编号小于N的最大编号提案，我们将该请求称为编号为N的prepare请求。<br>2.如果P收到了半数以上的A响应，那么它就可以生产编号N,value=v的提案[n,v].这里的v是所有响应中编号最大的提案value.如果所有A的响应中都没有批准过任何提案，那么此时v的值就由p任意选择。</p>
<p>在确定提案之后，p就会将该提案再次发送给某个a集合，并期望获得他们的批准，我们称次请求为accept请求。此时接受Accept请求的a集合并不一定是之前响应的a集合。</p>
<h4 id="Acceptor批准提案"><a href="#Acceptor批准提案" class="headerlink" title="Acceptor批准提案"></a>Acceptor批准提案</h4><p>上面出现了两种请求：<br>prepare:a to p,告诉p曾经接受过的最大编号的提案。<br>accpet: p to a,在编号被认可之后，p向a发送的提案信息</p>
<p>因此我们出现了以下约束，P1a:<code>一个a只要尚未响应过任何编号大于m的prepare请求，那么他就可以接受这个编号为m的提案</code>（这里的接受指的是接受编号）</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>假设一个a接收到了一个编号为m的prepare请求，但此时该a已经对编号大于m的请求做出了响应，因此他肯定不会再批准m，所以他没必要对此作出拒绝的响应，可以直接忽略。</p>
<p>这样每个a只需要记住他已经批准的提案的最大编号以及他已经作出prepare请求响应的提案的最大编号，以便在出现故障或者节点重启的情况下满足P2c的不变性。对于p，只要他保证不会产生具有相同编号的提案，那么就可以丢弃任意的提案以及他所有的运行时状态信息。</p>
<h3 id="算法陈述"><a href="#算法陈述" class="headerlink" title="算法陈述"></a>算法陈述</h3><p>阶段一：</p>
<p>1.p选择一个提案编号m,然后向a的某个超半数自己成员发送编号为m的prepare请求。<br>2.如果一个a收到一个编号为m的prepare请求，且编号m大于该a已经响应的所有prepare编号，那么他就会将他已经批准过的最大编号的<code>提案</code>(包含id和value)最为响应反馈给p，同时a承诺不会再批准任何编号小于m的提案。</p>
<p>阶段二：</p>
<p>1.如果p收到了来自半数以上a对于其发出的编号为m的prepare请求的响应，那么他就会发送一个针对[m,v]的提案的accept请求给a.注意，v的值就是收到的响应中编号最大的提案的值（有可能和自己提交的值不一致，是阶段一中a反馈给p的accept请求中的v值），如果响应中不包含任何提案，那么他可以是任意值。</p>
<p>2.如果a收到了这个[m,n]的请求，只要改a尚未对编号大于m的prepare请求作出响应，他就可以通过这个提案。</p>
<h4 id="提案获取"><a href="#提案获取" class="headerlink" title="提案获取"></a>提案获取</h4><p>前面说到了Learner,我们该怎么让learner获取提案呢？</p>
<p>1.l获取被选定提案的前提是，该提案已经被半数以上航的a批准，那么简单又直观的方法就是当一个a批准了一个提案，那么就发送给l,这种情况的缺点是通信次数多，为两者的乘积。<br>2.我们建立一个主l怎么样？所有a告诉主l,然后主l告诉其他l？看起来很不错，但是有单点失效问题。<br>3.再2的基础上，我们把主l变为主l群，这样不错，但是缺点在于网络通讯的复杂度较高。</p>
<h3 id="选取主proposer保证算法活性"><a href="#选取主proposer保证算法活性" class="headerlink" title="选取主proposer保证算法活性"></a>选取主proposer保证算法活性</h3><p>所谓活性，目前理解为有效性。假设有两个p依次提出一些列编号递增的议案，但是最终都没办法被选定：</p>
<p>p1提出了一个编号为1的提案，并完成了上述阶段1的流程。但是与此同时，p2又提出了一个编号为2的提案，同样也完成了1的流程，于是a承诺不再接受小于2的提案，当p1进入了阶段二，发送accept请求的时候，a就会忽略这个请求，于是p1发送编号为3的提案，这又导致p2在阶段二的请求被忽略，所以陷入死循环，称之为活锁。</p>
<p>为了保证算法的有效性，需要选择一个主p，并规定只有主p才能提出议案。这样一来，只要主p和过半的a可以正常通信，那么只要主p提出一个编号更高的提案，那么该提案最终会被批准。（这块是怎么做的？会和上述的约束矛盾么？”承诺不再接受编号小于m的提案”，这个原则会在主p身上变化么？）当然，如果p发现当前算法流程中有一个编号更大的提案被提出或正在接受批准，那么他会丢弃当前这个编号较小的提案。（a会忽略编号较小的提案的请求，那么p怎么发现？通过learner么？）</p>
<p>关于paxos补充：</p>
<p>上述paxos是basic paxos,会使用multi paxos来解决活锁问题。</p>
<p>“FLP已经指出异步模型下，任何一致性算法，哪怕只是容忍一个进程崩溃，都存在永不终止的可能性。因此Paxos不存在活锁是不可能的。”</p>
<p>“去掉了prepare啊。基本的paxos算法简直不能用，这是经过实际证明比较好的解决方案了。即使是用leader的方案，再选leader时还会出现活锁。<br>解决活锁用得方法一般是随机定时器啊。当发现冲突后，不同的提交者随机休眠一段时间，然后再次申请。”</p>
<h4 id="multi-paxos"><a href="#multi-paxos" class="headerlink" title="multi paxos"></a>multi paxos</h4><p>在理解了basic paxos之后，我们要对其进行优化，解决上述的问题，并且提高效率。<br>朴素paxos算法通过多伦的Preare/Accept过程来确定一个值，我们称这个过程为一个Instance. Multi paxos是通过paxos来确定很多歌值，而且这些值的顺序在各个节点完全一致。概括来讲就是确定一个全局顺序。</p>
<p>多个Instance怎么运作？我们先构建最简单的模式，各个Instance独立运作。P&amp;A:prepre and accept<br>|Instance|1|2|3|4|5|6|<br>|–<br>|paxos|P&amp;A|P&amp;A|P&amp;A|P&amp;A|P&amp;A|P&amp;A|</p>
<p>每个instance独立运作一个朴素paxos算法，我们保证仅当instance i的值被确定后，放可进行下一个paxos算法，这样我们就保证了Instance的有序性。</p>
<p>但是这样的效率是比较差的，朴素paxos算法的latency很高，multi-paxos算法希望找到多个Instance的paxos算法之间的联系，从而尝试在某些情况去掉prepare步骤。</p>
<hr>
<h2 id="目前对于paxos的理解只限于纸面层面，而multi-paxos则是几乎不理解，这块还需要深入的理解和补充，目前先往下进行zookeeper"><a href="#目前对于paxos的理解只限于纸面层面，而multi-paxos则是几乎不理解，这块还需要深入的理解和补充，目前先往下进行zookeeper" class="headerlink" title="目前对于paxos的理解只限于纸面层面，而multi paxos则是几乎不理解，这块还需要深入的理解和补充，目前先往下进行zookeeper"></a>目前对于paxos的理解只限于纸面层面，而multi paxos则是几乎不理解，这块还需要深入的理解和补充，目前先往下进行zookeeper</h2><h2 id="zookeeper-和-paxos"><a href="#zookeeper-和-paxos" class="headerlink" title="zookeeper 和 paxos"></a>zookeeper 和 paxos</h2><p>Apache ZooLeeper是Apache Hadoop的子项目发展而来，他为分布式应用提供了高效并且可靠的分布式协调服务，提供了诸如统一命名服务，配置管理和分布式锁等分布式基础服务。在解决分布式数据一致性方面，zk斌没有直接采用paxos算法，而是采用了ZAB(zookeeper atomic broadcast)的一致性协议。</p>
<p>zk是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于他实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master选举，分布式锁和分布式队列等功能。zk可以保证如下分布式一致性：</p>
<p><code>顺序一致性</code>：从一个客户端发起的事务请求，最终将会严格的按照其发起顺序被应用到zookeepr中去。<br><code>原子性</code>:所有的事务请求结果在整个集群中所有机器山的应用情况是一致的，也就是说，要么整个集群所有机器都成功的应用了某一个事务，要么都没有应用。一定不会出现集群中的部分机器用了该事务，而另外一部分并没有应用的情况。<br><code>单一视图</code>:无论客户端连接的是哪个zk服务器，其看到的服务端的数据模型都是一致的。<br><code>可靠性</code>:一旦服务端成功的应用了一个事务，并完成了对客户端的响应，那么该事物所引起的服务端状态会一致巴博留下来，除非与另一个事务又对其进行了变更。<br><code>实时性</code>：一般的实时性指的是一个事务被成功应用，那么客户端应该理解从服务端上个读取这个事务变更后的状态，这里需要注意的是，zk仅仅保证在一定时间内，客户端最终能够从服务器上读取到最新的数据状态。</p>
<h3 id="zk的设计目标"><a href="#zk的设计目标" class="headerlink" title="zk的设计目标"></a>zk的设计目标</h3><p>zk致力于提供一个高性能，高可用，并且具有严格的顺序访问空感知能力的分布式协调服务。</p>
<h4 id="简单的数据模型"><a href="#简单的数据模型" class="headerlink" title="简单的数据模型"></a>简单的数据模型</h4><p>zk使得分布式程序能够通过一个共享的，树形结构的名字空间来进行相互协调。这里说的树形结构的名字空间，是指zk服务器内的一个数据模型，其由一些列被称为ZNode的数据节点组成，总的来说，其数据模型类似于一个文件系统，而ZNode之间的层级关系，就像文件系统的目录结构一样。不过和传统的磁盘文件系统不同的是，zk将全量数据存储在内存中，以此来实现提高服务器吞吐，减少延迟的目的。关于zk的数据模型我们会在下方做详细的阐述。</p>
<h4 id="可以构建集群"><a href="#可以构建集群" class="headerlink" title="可以构建集群"></a>可以构建集群</h4><p>一个zk通常由一组机器组成，通常3-5台机器就可以组长一个可用的zk集群了。<br><img src="http://ogeojkg3t.bkt.clouddn.com/zookeeper.png" alt=""><br>组成zk集群的每台机器都会在内存中维护当前的服务器状态。并且每台机器之间都会保持着通信（每个都和leader通讯，如果leader宕机，那么重新选举leader,这是我目前的理解，不知道是否准确）。只要金群众存在超过一般的机器能够正常工作，那么整个集群就能够正常对外服务。</p>
<p>zk的客户端会选择则和集群中任意一台机器来共同传建一个TCP连接，而一旦客户端和某台zk服务器之间的连接断开后，客户端会自动连接到集群中的其他机器。</p>
<h4 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h4><p>对于每个来自客户端的跟新请求，zk都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用zk这个特性来实现更好层次的同步原语。</p>
<h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>由于zk将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因为他尤其适用以读操作为主应用场景。</p>
<h3 id="zk的基本概念"><a href="#zk的基本概念" class="headerlink" title="zk的基本概念"></a>zk的基本概念</h3><h4 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h4><p>通常在分布式系统中，购车呢过一个集群的每一台机器都有自己的角色，最典型的就是Master/Slave模式（主备模式），在这种模式中，我们把能够处理所有写操作的机器称为master机器，把所有通过异步复制的方式获取最新数据，并提供读服务的机器称为Slave机器。</p>
<p>但是在zk中，这些概念被颠覆了。他没有沿用传统的Master/Slave概念，而是引入了Leader,Follower，Observer三种角色。zk集群中所有机器通过一个Leader选举过程来选定一台被称为Leader的机器，Leader服务器为客户端提供读写服务，其他机器包括follower和observer都可以听读写服务，不过区别在于Observer不参与Leader的选举过程，也不参与写操作的”过半即成功”策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>Session是指客户端会话，在了解会话之前，我们先了解一下客户端连接。在zk中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。zk对外的服务端口是2181，客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次建立连接开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向zk服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch时间通知。Session的sessionTimeout值用来设定一个会话的超时时间。当由于服务器压力太大，网络故障或是客户端主动断开连接等各种原因导致客户端断开连接时，只要在sessionTimeout规定时间内能够重新连接上集群中任意一台服务器，那么之前创建的<code>会话</code>依然有效。</p>
<h4 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h4><p>在谈到分布式的时候，我们常说的节点是指集群的每一台机器，然而在zk中，节点分为两类，第一类同样是指构成集群的机器，我们称之为机器节点。第二类则是指数据模型中的数据单元，我们称之为数据节点——ZNode.zk将所有的数据存储在内存中，数据模型是一棵树，由斜杠(/)来进行分割的路径，就是一个ZNode,比如：/foo/path1.每个ZNode上都会保存自己的数据内容，同时还会保存一系列属性信息。</p>
<p>在zk中，ZNode可以分为持久节点和临时节点两类， 所谓持久及诶单是指一旦这个ZNode被创建了，除非主动进行ZNode的一处操作，否则这个ZNode将一直保存在zk上。而临时节点就不一样了，他的生命周期和客户端会话绑定。一旦client的会话失效，那么这个节点就会被移除。另外zk还允许用户为每一个节点添加一个特殊的属性：SEQUENTIAL,一旦节点被标记上这个属性，那么在这个节点被创建的时候，zk会自动在其节点后面追加一个整形数字，这个数字是一个由父节点维护的自增数字.</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>在前面我们已经提到，zk上的每个ZNode都会存储数据，对应每个ZNode. zk都会为其维护一个叫做stat的数据结果，stat中记录了这个ZNode的三个数据版本，分别是version(当前ZNode的版本)，cversion(当前ZNode子节点的版本)和aversion(当前ZNode的ACL版本，ACL的知识我们后续会讲)。</p>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>事件监听器是zk中一个很重要的特性，zk允许用户在指定节点上注册一些watcher,并在一些特定事件触发的时候，zk会将事件通知到感兴趣的客户端上去，该机制是zk实现分布式协调服务的重要特性。</p>
<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>zk采用了ACL(access control list)策略来进行权限控制,类似于unix文件系统的权限控制，zk定义了以下5种权限：</p>
<blockquote>
<ul>
<li>create:创建子节点的权限</li>
<li>read:获取节点数据和子节点列表的权限</li>
<li>write:更新节点数据的权限</li>
<li>delete:删除子节点的权限</li>
<li>admin:设置节点acl的权限</li>
</ul>
</blockquote>
<p>需要注意的是create和delete是针对子节点的权限控制，并非当前节点的。</p>
<h3 id="为什么选择ZooKeeper"><a href="#为什么选择ZooKeeper" class="headerlink" title="为什么选择ZooKeeper"></a>为什么选择ZooKeeper</h3><p>工业级产品/目前最好的方案之一/开源/免费</p>
<h2 id="ZK的ZAB协议"><a href="#ZK的ZAB协议" class="headerlink" title="ZK的ZAB协议"></a>ZK的ZAB协议</h2><p>在之前我们说了paxos算法，但是zk并不是paxos的实现，而是使用了ZAB(zk atomic broadcast)协议作为其数据一致性协议的核心算法。基于该协议，zk实现了使用一个单一的主进程来接受并处理客户端的所有事务请求。并采用ZAB的原子广播协议，将服务器数据的状态变更已事务Proposal的形式广播到所有的副本进程上去。ZAB协议的这个主备模型架构保证了同一时刻集群只能有一个主进程来广播服务器的状态变更，因此能够很好的处理客户端大量的并发请求。另一方面，考虑到是在分布式环境中，顺序执行的一些状态变更前后会存在一定的依赖关系，这样的依赖关系也对ZAB协议提出了一个要求：ZAB协议必须能够保证一个全局的变更序列被顺序应用，也就是说，ZAB协议保证如果一个状态变更已经被处理了，那么所有其依赖的状态变更都应该已经被提前处理掉了。最后，考虑到主进程可能在任何时候出现崩溃或者重启现象，因此，ZAB协议还需要做到在当前主线程出现上述情况下，依旧可以正常工作。</p>
<p>ZAB协议的核心是定义了对于那些会改变zk服务器数据状态的事务请求的处理方式：</p>
<blockquote>
<p>所有事务请求必须由一个全局卫衣的服务器来协调处理，这样的服务器被称为leader服务器，而余下的其他服务器则称为follwer服务器。Leader服务器负责将一个客户端的事务请求变成一个事务提议(proposal)，并将该Proposal分发给集群中所有follower.之后Leader服务器需要等待所有follower服务器的反馈，一旦超过半数的follower进行了正确的反馈后，那么leader就会再次像所有的follower服务器分发commit消息，要求将前一个proposal进行提交。</p>
</blockquote>
<h3 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h3><p>ZAB协议包括两种基本模式，<code>崩溃恢复</code>和<code>消息广播</code>。当整个服务框架在启动过程中，或是当leader服务器出现网络故障，崩溃重启等问题时，ZAB协议就会进入恢复模式并选举产生新的leader服务器，同事集群中已经有过半机器与该leader服务器完成了同步状态之后，ZAB就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</p>
<p>过半就可以么？(是的，然后会对其他的follow做状态的更新)新的leader怎么选举出来的，怎么保证他的状态和上一个l的状态一致？</p>
<p>当集群中已经有过半的follower服务器完成了和leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。当一台遵守了ZAB协议的服务器启动后加入进群中时，如果此刻集群中存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉的进入数据恢复模式：找到leader服务器并与其进行数据同步，然后一起参与到消息广播的流程中去。正如上文提到，zk设计成只允许唯一的一个leader服务器来进行事物请求的处理，leader服务器在接收到客户端的请求后，会生成对应的事务提案并发生一轮广播协议；如果集群中其他的机器接受到客户端的事务请求，那么这些非leader服务器会首先将这个事务请求转发给leader服务器。（如果出现了网络故障怎么办？client连接到哪一台机器上，是随机的么？）<br>当Leader服务器出现崩溃退出或者机器重启，亦或是集群中已经不存在过半的服务器与该leader服务器保持正常通信时，那么重新开始新一轮的原子广播事务操作之前，所有的进程首先会使用崩溃恢复协议使彼此达到一个一致的状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。</p>
<h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>ZAB协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。针对于客户端的事务请求，leader服务器会为其生成对应的事务proposal，并将其发送给集群总所有的机器，然后再分别收集各自的选票，最后进行事务提交。我们在上面讲解了关于二阶段提交协议的内容，而此处ZAB协议中涉及的二阶段提交过程则略有不同，在ZAB协议的二阶段提交过程中，移除中断的逻辑，所有的follower要么正常反馈Leader提出的事务proposal，要么就抛弃leader服务器。同时ZAB协议将二阶段提交的中断逻辑移除意味着我们可以在过半的follower服务器反馈ack之后就开始提交事务proposal,而不需要等待集群中所有的follower都反馈响应。当然，在这种简化的二阶段提交模型下，是无法处理leader服务器崩溃退出而带来的数据部不一致问题的，因此ZAB添加了另一个模式，即采用崩溃恢复模式来解决这个问题。另外，整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能很容易的保证消息广播过程中消息接收与发送的顺序性。<br>在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的proposal来进行广播，并且在广播事务proposal之前，leader服务器会为proposal分配一个全局递增的唯一ID,我们称之为事务ID（ZXID）,由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务proposal按照其ZXID的先后顺序来进行排序和处理。<br>具体的，在消息的广播过程中，leader服务器会为每一个follower服务器各自分配一个单独的队列，然后将需要广播的事务proposal依次放入这些队列中去，并且根据FIFO策略进行消息发送。每一个follower服务器再接收到这个事务proposal之后，<code>都会首先将事务以日志形式写入到本地磁盘中去</code>，并且在成功写入后follower会给leader服务器一个ack响应。当leader收到了半数以上相应后，就会广播一个commit消息给所有的follower服务器通知其事务进行提交，而每一个follower服务器再借收到消息之后也会对事物进行提交。</p>
<h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>一旦leader服务器出现崩溃，或者由于网络原因导致leader服务器失去了与过半follower的联系，那么就会进入崩溃恢复模式。为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的leader服务器。因此，ZAB需要一个高效并且可靠的leader选举算法，从而确保能够快速的选举为新的leader,同事还需要让集群中的所有机器也能偶快速地感知到选举产生的新的leader服务器</p>
<h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><p>ZAB协议规定了如果一个事务的proposal在一台机器上被处理成功，那么应该在所有的机器上都被处理成功，哪怕机器出现故障崩溃。接下来我们看看在崩溃恢复过程中，可能会出现的两个数据不一致的隐患，以及针对这些情况ZAB协议需要保证的特性。<br><code>ZAB协议需要确保哪些已经在Leader服务器上提交的事务最终被所有服务器提交</code><br><code>ZAB协议需要确保丢弃哪些只在leader服务器上被提出的事务</code></p>
<p>结合上面提到的这两个崩溃恢复构成中需要处理的特殊情况，就决定了ZAB协议必须设计这样一个leader选举算法：能够确保提交已经被leader提交的事务proposal,同时丢弃已经被跳过的事务proposal.针对这个要求，如果让leader选举算法能够保证新选举出来的leader服务器拥有集群中所有机器最高编号（ZXID最大）的事务proposal,那么就可以保证这个新选举出来的leader一定具有所有已提交的提案。更为重要的是，如果让具有最高编号事务proposal的机器来称为leader,就可以省去leader服务器检查proposal的提交和丢弃工作的这一步操作了。</p>
<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>完成leader选举之后，在正式开始工作之前，leader会首先确认事务日志中的所有proposal是否都已经被集群中过半的机器提交了，即是否完成了同步，过程如下：</p>
<blockquote>
<p>所有正常运行的服务器，要么成为leader,要么成为follower并和leader保持同步。leader服务器需要确保所有的f服务器能够接受到每一条事务的proposal，并且能够正确的将所有已经提交的事务的proposal应用到内存数据库中。具体的，leader服务器会为每一个f服务器准备一个队列，并将那些没有被各个follower服务器同步的事务以proposal形式应用到内存数据库中。具体的，leader服务器会为每一个f服务器准备一个队列，并将那些没有被各f服务器同步的事务（怎么确定没有被发送？先采集follower中最大的编号么？）以proposal的形式逐个发给f服务器，并在每一个proposal请求后再发送一个commit消息，以表示该事务已经被提交。等到f服务器将所有尚未同步的事务p从l服务器同步过来并成功应用到本地数据库中后，l服务器就会将该follower服务器加入真正可用的f列表中，并开始之后的其他流程。</p>
</blockquote>
<p>上面将的是正常的数据同步逻辑，我们看看ZAB协议是怎么处理那些需要被丢弃的proposal的。在ZAB协议的事务编号ZXID设计中，ZXID是一个64位的数据，其中低32位可以看做事一个简单的单调递增的计数器，针对客户端的每一个事务请求操作，l服务器在产生一个新的事务p的时候，都会对该计数器进行+1操作。而高32位代表l周期的epoch的编号，每当选举产生一个新的l服务器，就会从这个l服务器上取出本地日志中最大事务proposal的ZXID,并从该ZXID中解析出对应的epoch值，然后再对其进行+1操作，之后就会以此编号作为新的epoch,并将低32位置重置为0来开始生成新的ZXID.ZAB协议中的这一通过epoch编号来区分l周期变化策略，能够有效的避免不同的l服务器错误的使用形同的ZXID编号提出不一样的事务的p的异常情况，这对于识别在l崩溃恢复前后生成的proposal非常有帮助，大大简化和提升了数据恢复流程。</p>
<p>基于这样的策略，当一个包含了上一个leader中其中尚未提交过的事务proposal的服务器启动时，肯定无法成为leader,原因很简单，因为当前集群中一定包含一个Quorum集合，该集合中的机器一定包含了更高epoch事务proposal,因此这台机器的事务proposal肯定不是最高，也就无法成为leader了。当这台机器加入到集群中，以follower角色连接上leader服务器之后，leader服务器会根据自己服务器上最后被提交的proposal来和follower服务器的proposal进行比对，比对的结果当然是l要求f来进行一次回退，回退到上一个确实已经被一半集群以上提交的事务proposal.</p>
<h3 id="深入ZAB协议"><a href="#深入ZAB协议" class="headerlink" title="深入ZAB协议"></a>深入ZAB协议</h3><h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><p>通常在一个由一组进程组成的I={p1,p2…pn}组成的分布式系统中，每一个进程都具有各自的存储设备，各进程之间通过通信来实现消息传递。一般的，在这样的一个分布式系统中，每一个进程都随时有可能出现一次或者多次的崩溃退出，当然，这些进程会在恢复之后重新加入到进程组I中。如果一个进程正常工作，那么我们称之为up状态，崩溃了就称之为down状态。事实上，当集群中存在过半的处于up状态的进程组成了一个进程子集之后，我们就可以正常的进行消息广播了。我们将这样的一个进程子集称为Quorum(法定人数)，并假设这样的Q已经存在，并且满足：<br>1.有这样的一个进程子集Q,他必定是I的子集<br>2.存在两个进程子集Q1和Q2,其交集必定为非空</p>
<p>我们使用Pi和Pj来分别表示进程组I的不同进程，Cij来表示Pi和Pj之间的通信通道，其满足以下两个基本特性：</p>
<h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><p>进程Pj如果收到来自进程Pi的消息m，那么进程Pi一定确实发送了消息m</p>
<h4 id="前置性"><a href="#前置性" class="headerlink" title="前置性"></a>前置性</h4><p>如果Pj收到了消息m,那么存在这样的消息m’:如果消息m’是m的前置消息，那么Pj务必先接受到消息m’,然后在接收到m.我们将这种前置性的两个消息表示为:m’&lt; m.前置性是整个协议设计中最关键的一点，由于每一个小时都可能是基于之前的消息来进行的，因此所有的消息都必须按照严格的先后顺序来进行处理。</p>
<h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>根据业务场景，zk需要有高吞吐，低延迟，良好的一致性管理，并且可以快速的可以从故障中回复。</p>
<p>ZAB协议是zk框架的核心所有，它规定了任何时候都需要保证只有一个主进程负责消息广播，如果主进程崩溃了，就需要选举出一个新的主进程。主进程的选举机制和消息广播机制是密切相关的。随着时间的推移，会出现无限多个主进程并构成一个主进程序列:P1,P2….Pe. e表示主进程的序列号，也被称作主进程周期。对于任意两个主进程来说，如果a &lt; b，那么Pa就是Pb之前的主进程。由于每个进程都会发生崩溃后再次恢复，因此会存在Pa和Pb本质上是同一个进程，只不过处于不同的周期中而已。</p>
<h3 id="主进程周期"><a href="#主进程周期" class="headerlink" title="主进程周期"></a>主进程周期</h3><p>为了保证主进程每次广播出来的事务消息都是一致的，ZAB保证在崩溃恢复阶段完成之后，新的主进程才可以生成新的事物消息广播。为了实现这个目的，我们假设每个进程都实现了类似于ready(e)这样的一个函数调用，在运行过程中，ZAB协议能够非常明确的告知上层系统(指主进程和其他副本进程)是否可以开始事务消息的广播，同时在调用ready(e)之后，ZAB还需要为当前主进程设置一个实例值(上面所说的前32位)，用于唯一标识当前主进程的周期。在进行消息广播的时候，主进程使用该实例值来设置事务标识中的epoch字段，当然，ZAB需要保证实例值在不同的主进程周期中是全局唯一的。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>我们假设各个进程都存在一个类似于transactions(v,z)这样的调用，来实现主进程对状态变更的广播，事务内容v和事务标识z.而一个z也包含了连个部分，主进程周期e，当前进程周期内的事务计数c.我们使用epoch(z)来表示事务标识中的主进程周期，counter(z)来表示事务标识中的事务计数。</p>
<p>针对每一个新的事务，主进程都会首先将事务计数c递增。在实际运行过程中，如果一个事务标识z优先于另一个事务标识z’,无论是epoch(z) &lt; epoch(z’)还是epoch(z) = epoch(z’) 并且counter(z) &lt; counter(z’),无论哪种情况，都是用 z &lt; z’来表示。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><h2 id="ZAB协议主要包括消息广播和崩溃恢复连个过程，进一步可以细分为三个阶段："><a href="#ZAB协议主要包括消息广播和崩溃恢复连个过程，进一步可以细分为三个阶段：" class="headerlink" title="ZAB协议主要包括消息广播和崩溃恢复连个过程，进一步可以细分为三个阶段："></a>ZAB协议主要包括消息广播和崩溃恢复连个过程，进一步可以细分为三个阶段：</h2><p>简单看了一下，说的就是选举leader，分发消息，崩溃恢复的机制，然后和paxos对比了一下。</p>
<h2 id="有没有完全理解明白？没有。有没有完全理解paxos-依旧没有，不过没问题，先往下走一走，理论的东西看的有点多，这协议会回头继续理解的"><a href="#有没有完全理解明白？没有。有没有完全理解paxos-依旧没有，不过没问题，先往下走一走，理论的东西看的有点多，这协议会回头继续理解的" class="headerlink" title="有没有完全理解明白？没有。有没有完全理解paxos? 依旧没有，不过没问题，先往下走一走，理论的东西看的有点多，这协议会回头继续理解的"></a>有没有完全理解明白？没有。有没有完全理解paxos? 依旧没有，不过没问题，先往下走一走，理论的东西看的有点多，这协议会回头继续理解的</h2>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/24/从PAXOS到ZOOKEEPER分布式一致性原理与实践/" class="archive-article-date">
  	<time datetime="2017-03-24T07:11:37.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2017/03/17/GET&POST/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">GET &amp; POST</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="从PAXOS到ZOOKEEPER分布式一致性原理与实践" data-title="从PAXOS到ZOOKEEPER分布式一致性原理与实践." data-url="http://tiltcat.com/2017/03/24/从PAXOS到ZOOKEEPER分布式一致性原理与实践/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 tiltcat
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/CAS/" style="font-size: 10px;">CAS</a> <a href="/tags/Concurrent/" style="font-size: 16.67px;">Concurrent</a> <a href="/tags/Design-Pattern/" style="font-size: 10px;">Design Pattern</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/IoC/" style="font-size: 10px;">IoC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 10px;">Netty</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/事务管理/" style="font-size: 13.33px;">事务管理</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/数据类型/" style="font-size: 10px;">数据类型</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;br&gt;大家好，我叫周克，独生子女&lt;br&gt;名字是我出生的时候二大爷起的 &lt;br&gt;没有固定职业，为了吃饭到处打零工&lt;br&gt;爱好篮球和吃火锅&lt;br&gt;没什么理想，平时也不爱想，嫌累&lt;br&gt;总体上来说就是：胸无大志，混吃等死&lt;br&gt;以上都是我瞎编的 &lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>