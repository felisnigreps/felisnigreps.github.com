<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://tiltcat.com">
  <title>知识点 | Let&#39;s do this</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面试之前总会去复习一下知识点,有些小的知识点很零碎,每次查还不如在这记录一下,都很简单,只不过多熟悉下概念~">
<meta name="keywords" content="知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点">
<meta property="og:url" content="http://tiltcat.com/2017/08/24/知识点/index.html">
<meta property="og:site_name" content="Let&#39;s do this">
<meta property="og:description" content="面试之前总会去复习一下知识点,有些小的知识点很零碎,每次查还不如在这记录一下,都很简单,只不过多熟悉下概念~">
<meta property="og:updated_time" content="2017-09-21T07:50:48.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知识点">
<meta name="twitter:description" content="面试之前总会去复习一下知识点,有些小的知识点很零碎,每次查还不如在这记录一下,都很简单,只不过多熟悉下概念~">
  
  
    <link rel="icon" href="/images/favicon.jpg">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">tiltcat</a></h1>
		</hgroup>

		
		<p class="header-subtitle">wub lab dup dup</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/felisnigreps" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/cool5231" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tilt-play" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">tiltcat</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/avatar.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">tiltcat</h1>
			</hgroup>
			
			<p class="header-subtitle">wub lab dup dup</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/felisnigreps" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/cool5231" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tilt-play" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      知识点
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>面试之前总会去复习一下知识点,有些小的知识点很零碎,每次查还不如在这记录一下,都很简单,只不过多熟悉下概念~</p>
<a id="more"></a>
<h4 id="重载和覆盖"><a href="#重载和覆盖" class="headerlink" title="重载和覆盖"></a>重载和覆盖</h4><p>重载用于构造方法等,同样的方法有不同的形式,覆盖一般用于父类子类. 重载的方法名必须相同,参数类型和个数或者顺序必须要有一个不同,返回值不在考虑之内.覆盖的方法名参数等必须相同,异常&lt;=父类,访问修饰符&gt;=父类</p>
<h4 id="值传递-引用传递"><a href="#值传递-引用传递" class="headerlink" title="值传递/引用传递:"></a>值传递/引用传递:</h4><p>首先要明确Java中是没有引用传递的,全部都是值传递.<br>如果参数是基本变量,那么传递的是参数的值的拷贝.<br>如果参数是非基本变量,那么传递的是参数在堆中的内存地址.<br><code>对象实例化了，栈内存中存放的是对象的引用，也就是对象在堆内存中的地址</code></p>
<h4 id="线程进程的区别"><a href="#线程进程的区别" class="headerlink" title="线程进程的区别"></a>线程进程的区别</h4><p>线程是JVM操作的最小单位,进程是CPU操纵的最小单位,一个进程可以包括多个线程.</p>
<h4 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h4><p>Java中是单继承,代表子类可以拥有父类的一些属性或者方法,父类更抽象,子类更具体,所有类继承Object.</p>
<h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><p>GC Roots的使用不当会导致内存泄露,包括final,static. String就是final calss.<br>Map,List等引用不清空也会导致内存泄露</p>
<h4 id="Linux下的-proc是什么"><a href="#Linux下的-proc是什么" class="headerlink" title="Linux下的/proc是什么"></a>Linux下的/proc是什么</h4><p>是linux提供的一个伪文件系统,里面包含了系统的运行状态信息,存储内核运行状态的一系列文件,用户可以查看这些文件来找到硬件和进程信息.</p>
<h4 id="Linux如何修改进程优先级"><a href="#Linux如何修改进程优先级" class="headerlink" title="Linux如何修改进程优先级"></a>Linux如何修改进程优先级</h4><p>优先级从-20到19,越大优先级越低,改变优先级有两个办法:</p>
<ol>
<li>top,NI的数值就是优先级,输入r,然后根据提示输入pid和优先级</li>
<li>renice -n 2 -p 3142  (n是优先级 p是pid)</li>
</ol>
<h4 id="semaphore与lock的区别"><a href="#semaphore与lock的区别" class="headerlink" title="semaphore与lock的区别"></a>semaphore与lock的区别</h4><p>semaphore维护一组信号量,是非独占锁(none-exclusive lock). Lock是juc下的一个接口,提供了lock,unlock,trylock等方法.ReetrantLock等实现了Lock接口</p>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>死锁是多个线程同时尝试获取一个锁,引起了等待而完成的.我们可以通过明确获取顺序来避免死锁,可以使用同步,队列等.</p>
<h4 id="list-vector区别"><a href="#list-vector区别" class="headerlink" title="list/vector区别"></a>list/vector区别</h4><p>vector线程同步,其余一样</p>
<h4 id="红黑树的-复杂度？"><a href="#红黑树的-复杂度？" class="headerlink" title="红黑树的**复杂度？"></a>红黑树的**复杂度？</h4><p>这边先简单说下,以后有机会单独写红黑树.<br>我觉得目前不太可能让你拿个白板去写红黑树,那么简单说说它的原理.</p>
<p>首先他和BST(Binary serach tree)有什么区别,好处是什么?BST面对的最大的问题就是删除之后的树的层次不能保持平衡,最坏的情况是O(N). 而红黑树呢,他会根据节点的颜色进行左旋和右旋来对树的层次进行优化,这就是我们采用红黑树的原因了.<br>只有在父节点为红色节点的时候是需要插入修复操作的.删除修复操作是针对删除黑色节点才有的.</p>
<p>红黑树的操作时间跟二叉查找树的时间复杂度是一样的，执行查找、插入、删除等操作的时间复杂度为O（logn）</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>简单来说反射就是可以让你调用你没有实例化的东西。记得你使用IDE的时候，对象.会有提示是吧？<br>几种方式实现：</p>
<blockquote>
<ul>
<li>classLoader</li>
<li>类名.class</li>
<li>对象名.getClass()</li>
<li>Class.forName();</li>
</ul>
</blockquote>
<h4 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h4><p>有一个面试问问到的,以前就是简单看了下,结果真的说起来发现自己不太懂,问题不大,现在来说一下.<br>首先这俩单词读起来要准~(笑),百度就好了,虽然看起来很像,读起来差别还是蛮大的.<br>先说Comparable,这主要给是对象的内部定义的顺序,有些排序方法比如Array.sort()和Collection.sort()的参数需要实现了Comparator,看代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableDemo</span> </span>&#123;</div><div class="line">    <span class="comment">//内部的比较排序</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> age;</div><div class="line">        String name;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</div><div class="line">            <span class="comment">//  return this.age - o.age;</span></div><div class="line">            <span class="keyword">return</span> o.age - <span class="keyword">this</span>.age;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> name + <span class="string">":"</span> + age;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//比较明了</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Person a = <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">"Jim"</span>);</div><div class="line">        Person b = <span class="keyword">new</span> Person(<span class="number">22</span>, <span class="string">"Bob"</span>);</div><div class="line">        Person c = <span class="keyword">new</span> Person(<span class="number">17</span>, <span class="string">"Lisa"</span>);</div><div class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(a);</div><div class="line">        list.add(b);</div><div class="line">        list.add(c);</div><div class="line">        System.out.println(list);</div><div class="line">        Collections.sort(list);</div><div class="line">        System.out.println(list);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再说comparator,这是在外部定义的排序规则,话不所说,看代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorDemo</span> </span>&#123;</div><div class="line">    <span class="comment">//外部的排序</span></div><div class="line">    <span class="comment">//内部的比较排序</span></div><div class="line">    <span class="comment">//name,age,set/get,toString</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//比较明了</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Person a = <span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">"Jim"</span>);</div><div class="line">        Person b = <span class="keyword">new</span> Person(<span class="number">22</span>, <span class="string">"Bob"</span>);</div><div class="line">        Person c = <span class="keyword">new</span> Person(<span class="number">17</span>, <span class="string">"Lisa"</span>);</div><div class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(a);</div><div class="line">        list.add(b);</div><div class="line">        list.add(c);</div><div class="line">        System.out.println(list);</div><div class="line">       </div><div class="line">        <span class="comment">//顺序的话可以采用comparingInt方法</span></div><div class="line">        <span class="comment">// Collections.sort(list,(Comparator.comparingInt(o -&gt; o.age)));</span></div><div class="line">       </div><div class="line">        <span class="comment">//同样是逆序</span></div><div class="line">        <span class="comment">//Collections.sort(list,((o1, o2) -&gt; o2.age-o1.age));</span></div><div class="line">       </div><div class="line">        <span class="comment">//可以通过这么定义来调用reversed方法来实现逆序</span></div><div class="line">        Comparator&lt;Person&gt; comparator = Comparator.comparingInt(Person::getAge);</div><div class="line">        Collections.sort(list, comparator.reversed());</div><div class="line">        System.out.println(list);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大部分的代码都可以在git上找到</p>
<h4 id="TCP的安全性-三次握手-四次挥手"><a href="#TCP的安全性-三次握手-四次挥手" class="headerlink" title="TCP的安全性/三次握手 四次挥手"></a>TCP的安全性/三次握手 四次挥手</h4><p>TCP的三次握手我们都清楚了,简单说下,为什么要三次握手呢?<br>三次握手的作用是避免”已经时效的连接请求报文段”.</p>
<p>假设以下场景,client端发出请求并不是丢失了,而是在某个网络节点滞留了,在之后的某一个时间点到达server.对于client来讲,这个请求已经失效了,但是server接收到的时候会认为这还是一个有效的请求,那么他就会向client发出确认报文段,同意建立连接,假设没有三次握手阶段,只要server发出确认,新的连接已经建立了.但是client没有发出建立连接的请求,那么自然不会理睬server的连接,那么server端的资源就被白白浪费掉了.</p>
<p>下面说说四次挥手.先解释一个概念，单工和双工。<br>所谓单工，就是只能A到B或者B到A，数据时单向且固定的。<br>双工分半双工和全双工，半双工指的是A B之间都可以收发，但是在某一个时刻只能进行其中的一种情况。<br>全双工指的就是两端都可以自由收发。<br>四次挥手是断开连接的过程，由于TCP是全双工的，因此每个方向都要单独进行关闭，这一个原则是当一方完成数据任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一个方向上没有数据流动了，但是仍旧可以这条通道上依旧可以发送数据（双向），首先关闭的一方将主动执行关闭，另一方则被动执行关闭。<br>简单例子：<br>1.client发送一个fin，client进入fin_wait_1状态<br>2.server收到fin后，发送一个ack给client,确认序号为收到序号+1，server进入close_wait状态<br>3.server发送一个fin,用来关闭server到client的数据传送，server进入last_ack状态<br>4.client收到fin之后，进入time_wait状态，接着发送一个ack给server,确认序列号为收到序号+1，server进入closed状态，完成四次挥手。</p>
<p>TCP如何保证传输安全? TCP的头部会有有checksum来校验字段的长度,但是还是存在篡改checksum来破坏安全性的情况发生.所以有一个option19的方式来对他进行加密,核心是通过MD5 Hash算法以报文内容和pre-shared key来生成MD5 Hash来进行校验来保证安全性.</p>
<h4 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h4><p>session在服务器端,cookie在客户端(浏览器)<br>session默认被存在服务器的一个文件里<br>session的运行依赖session id,session id是存在cookie中的,也就是说如果浏览器禁用了cookie,session也会失效.<br>session可以放在文件,数据库,或者内存中都可以<br>用户验证一般都会用session,维持一个会话的核心就是客户端的唯一标识.</p>
<h4 id="dopost和doget区别"><a href="#dopost和doget区别" class="headerlink" title="dopost和doget区别"></a>dopost和doget区别</h4><p>POST和GET的差别其实是很大的。语义上，GET是获取指定URL上的资源，是读操作，重要的一点是不论对某个资源GET多少次，它的状态是不会改变的，在这个意义上，我们说GET是安全的（不是被密码学或者数据保护意义上的安全）。因为GET是安全的，所以GET返回的内容可以被浏览器，Cache服务器缓存起来（其中还有很多细节，但不影响这里的讨论）。<br>而POST的语意是对指定资源“追加/添加”数据，所以是不安全的，每次提交的POST，参与的代码都会认为这个操作会修改操作对象资源的状态，于是，浏览器在你按下F5的时候会跳出确认框，缓存服务器不会缓存POST请求返回内容。<br>安全的是指没有明显的对用户有影响的副作用(包括修改该资源的状态)。HTTP方法里的GET和HEAD都是安全的。<br>幂等的是指一个方法不论多少次操作，结果都是一样。PUT(把内容放到指定URL)，DELETE(删除某个URL代表的资源)，虽然都修改了资源内容，但多次操作，结果是相同的，因此和HEAD，GET一样都是幂等的。<br>所以根据HTTP协议，GET是安全的，也是幂等的，而POST既不是安全的，也不是幂等的。</p>
<h4 id="hashtable详解"><a href="#hashtable详解" class="headerlink" title="hashtable详解"></a>hashtable详解</h4><p>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。<br>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。</p>
<h4 id="Java-final关键字"><a href="#Java-final关键字" class="headerlink" title="Java final关键字"></a>Java final关键字</h4><p>1.final关键字可以用于成员变量、本地变量、方法以及类。<br>2.final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。<br>3.你不能够对final变量再次赋值。<br>4.final方法不能被重写。<br>5.final类不能被继承。<br>6.final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。<br>7.接口中声明的所有变量本身是final的。</p>
<h4 id="在N个无序的数中找出第M大的数字"><a href="#在N个无序的数中找出第M大的数字" class="headerlink" title="在N个无序的数中找出第M大的数字"></a>在N个无序的数中找出第M大的数字</h4><p>这种类型的题有很多种解法，最简单的做法无非是先整体排完序之后直接找第M个数，这种的效率明显是很低的。我这里使用快速排序的思想来解这道题，首先在无序数中随便找一个数作为中间值（我这里用的是第一个数），然后将比中间值大的数移动到中间值左边，比中间值大的数移动到中间值右边，分完之后会出现这样的情况：<br>1.当左边区间的个数大于等于M时（第M大），则递归该区间<br>2.当左边的区间小于M且与M相差1时，则输出中间值<br>3.以上两种情况都不符合时，递归右边区间，找到右边区间第 {M-1-（左边区间个数）}大的数</p>
<h4 id="一个列表如何去掉重复的元素"><a href="#一个列表如何去掉重复的元素" class="headerlink" title="一个列表如何去掉重复的元素"></a>一个列表如何去掉重复的元素</h4><p>存到set里</p>
<h4 id="数据库的join"><a href="#数据库的join" class="headerlink" title="数据库的join"></a>数据库的join</h4><p>left join以left join前面的表为主表，把left join后面的表符合on条件的内容加到主表中，如果没有符合on条件的内容，则显示为NULL<br>right join 以right join后面的表为主表，把right join前面的表符合on条件的内容加到主表中，如果没有符合on条件的内容，则显示为NULL<br>inner join 就是返回两个表中符合on条件的记录，若不满足条件则不返回</p>
<h4 id="检查一段字符串中左右括号是否全部匹配"><a href="#检查一段字符串中左右括号是否全部匹配" class="headerlink" title="检查一段字符串中左右括号是否全部匹配"></a>检查一段字符串中左右括号是否全部匹配</h4><p>使用栈,扫描到左括号就压栈,右括号就和栈顶元素比较.</p>
<h4 id="如何防止SQL注入攻击"><a href="#如何防止SQL注入攻击" class="headerlink" title="如何防止SQL注入攻击"></a>如何防止SQL注入攻击</h4><p>PreparedStatement,正则表达式过滤,前台过滤等.</p>
<h4 id="快速排序的复杂度"><a href="#快速排序的复杂度" class="headerlink" title="快速排序的复杂度"></a>快速排序的复杂度</h4><p>O(logN)<br>最近在研究算法，书上一直说时间是O（logn），但是没有明确说logn的底是什么.算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定.你如果采用二分法,那么就会以2为底数,三分法就会以3为底数,其他亦然.不过无论底数是什么,log级别的渐进意义是一样的.也就是说该算法的时间复杂度的增长与处理数据多少的增长的关系是一样的</p>
<h4 id="问什么是跨域攻击XSS"><a href="#问什么是跨域攻击XSS" class="headerlink" title="问什么是跨域攻击XSS"></a>问什么是跨域攻击XSS</h4><p>xss表示Cross Site Scripting(跨站脚本攻击)，通过插入恶意脚本，实现对用户游览器的控制.<br>假如用户提交的数据含有js代码，不做任何处理就保存到了数据库，读出来的时候这段js代码就变成了可执行的代码，将会产生意向不到的效果。一般用户提交的数据永远被认为是不安全的，在保存之前要做对应的处理。<br>我提交的内容</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;alert(1111) &lt;/script&gt; </div><div class="line">或者&lt;a href="www.baidu.com"&gt;百度&lt;/a&gt;</div><div class="line">读出来的时候，将直接弹出1111，或者百度是有效的超链接，这个显然是不行的。</div></pre></td></tr></table></figure>
<p>就是要注意过滤html里面的javascript标签就可以了，否则后果很严重.</p>
<h4 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h4><p>JVM里会有两种StackOverflowError, 一种是对应JVM stack, 一种是对应Native Method stack. 我们一般说的都是JVM stack.<br>每一个JVM线程维护自己的JVM stack. JVM stack里面存放JVM栈帧. 栈帧中存放数据和中间结果(本地变量数组, 操作符栈, 和对runtime 常量池的引用).这些数据都比较小(对象都在堆中, 栈帧仅存放对象引用), 所以想单纯通过在栈帧中存放大数据的方法去引入StackOverflowError, 基本是不现实的.一般都是因为方法调用嵌套层数过大.</p>
<p>JVM stack的大小是可以调节的, -Xss1024k来调节.</p>
<h4 id="Foreigh-key-和-Primary-Key"><a href="#Foreigh-key-和-Primary-Key" class="headerlink" title="Foreigh key 和 Primary Key"></a>Foreigh key 和 Primary Key</h4><p>主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。<br>外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。</p>
<h4 id="什么是B树，和二叉树的区别。"><a href="#什么是B树，和二叉树的区别。" class="headerlink" title="什么是B树，和二叉树的区别。"></a>什么是B树，和二叉树的区别。</h4><p>二叉好理解，就两个分支的那种，只有两个分支<br>B树，B+树都是平衡树(多叉),B+树会把非孩子节点的值写到孩子节点中去.</p>
<h4 id="什么是linkedlist"><a href="#什么是linkedlist" class="headerlink" title="什么是linkedlist"></a>什么是linkedlist</h4><p>Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).<br>双向链表,插入时间复杂度O(1)</p>
<h4 id="快排序"><a href="#快排序" class="headerlink" title="快排序"></a>快排序</h4><p>重新写下代码,git上有. 递归和迭代两种方式.</p>
<h4 id="判断一个数是否为素数"><a href="#判断一个数是否为素数" class="headerlink" title="判断一个数是否为素数"></a>判断一个数是否为素数</h4><p>TBD</p>
<h4 id="分布式系统中怎么保持数据的一致性"><a href="#分布式系统中怎么保持数据的一致性" class="headerlink" title="分布式系统中怎么保持数据的一致性"></a>分布式系统中怎么保持数据的一致性</h4><p>参见paxos博文,CAP原理.保持弱一致性.</p>
<h4 id="stack-heap区别"><a href="#stack-heap区别" class="headerlink" title="stack/heap区别"></a>stack/heap区别</h4><p>堆和栈,栈分为本地方法栈和虚拟机栈,参见JVM log.</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>参见设计模式blog</p>
<h4 id="JDK8的新特性"><a href="#JDK8的新特性" class="headerlink" title="JDK8的新特性"></a>JDK8的新特性</h4><p>1.接口可以实现默认方法,使用default修饰<br>2.lambda表达式<br>3.函数式接口 @FunctionalInterface.每一个lambda表达式都对应一个类型,这个类型就是函数式接口.他只有一个抽象方法,如果你的接口满足这个条件那么你可以使用这个注解,但是如果你的方法中有超过一个抽象方法,编译器会报错.<br>4.方法与构造函数引用,比如说Integer:paesrInt,返回值是一个函数式接口,具体代码参加github/javaBasic<br>5.Lambda 作用域.在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。<br>6.访问局部变量,我们可以直接在lambda表达式中访问外层的局部变量<br>7.Steam,可以理解为collection的加强,可以进行遍历,过滤,去重,自定义运算等等,还可以设置单线程或者多线程执行,详情见代码.github/javaBasic<br>8.Date API,线程安全. 相关的具体例子目前先不试了,具体参考 <a href="http://www.importnew.com/15637.html" target="_blank" rel="external">http://www.importnew.com/15637.html</a></p>
<h4 id="单点登录系统说一下"><a href="#单点登录系统说一下" class="headerlink" title="单点登录系统说一下"></a>单点登录系统说一下</h4><p>总体来说就是有一个sso认证中心,和所有的子系统进行交互,当系统无法识别这个用户的时候会像认证中心看是否有此用户的令牌(用户id).注销也一样,如果一个系统注销了,那么被注销的系统会像sso中心发送信息,sso会像所有系统发送注销请求.<br><a href="http://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="external">http://www.cnblogs.com/ywlaker/p/6113927.html</a><br>简单流程如下：<br>1.用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数<br>2.sso中心发现用户没有登录，将用户引导至登录界面<br>3.用户提交username和pw进行登录申请<br>4.sso校验用户信息，创建用户与sso之间的会话，称为全局会话，并且创建授权令牌<br>5.sso会带着令牌跳转回系统1<br>6.系统1使用该令牌创建与用户的对话，称为局部对话，返回受保护资源<br>7.用户访问系统2的受保护资源<br>8.系统2发现用户未登录，跳转到sso，并将自己的地址作为参数<br>9.sso发现用户已登录，跳转回系统2的地址，并附上令牌<br>10.系统2拿到令牌，去sso校验令牌是否有效<br>11.sso返回有效，注册系统2<br>12.系统2使用该令牌创建与用户的局部会话，返回受保护资源</p>
<h4 id="G1回收器和其他回收器有什么区别？"><a href="#G1回收器和其他回收器有什么区别？" class="headerlink" title="G1回收器和其他回收器有什么区别？"></a>G1回收器和其他回收器有什么区别？</h4><p>参见JVM博文</p>
<h4 id="垃圾回收为什么会停顿？哪些对象可能作为GCRoots"><a href="#垃圾回收为什么会停顿？哪些对象可能作为GCRoots" class="headerlink" title="垃圾回收为什么会停顿？哪些对象可能作为GCRoots?"></a>垃圾回收为什么会停顿？哪些对象可能作为GCRoots?</h4><p>个人理解stop the world是清理垃圾的一个必须步骤，体现在不同垃圾回收器的不同阶段。比如G1的标记阶段，只有程序停止了才能更好的进行标记和整理。<br>GC roots:<br>1.虚拟机栈<br>2.本地方发栈(native 方法)<br>3.static<br>4.final</p>
<h4 id="垃圾回收分代收集算法？"><a href="#垃圾回收分代收集算法？" class="headerlink" title="垃圾回收分代收集算法？"></a>垃圾回收分代收集算法？</h4><p>Serial ParNew Parallel(old) CMS G1<br>标记清除<br>标记整理<br>标记复制</p>
<h4 id="静态代理和动态代理的区别？动态代理是怎么实现的？"><a href="#静态代理和动态代理的区别？动态代理是怎么实现的？" class="headerlink" title="静态代理和动态代理的区别？动态代理是怎么实现的？"></a>静态代理和动态代理的区别？动态代理是怎么实现的？</h4><p>所谓静态代理是在程序运行前就已经存在代理类的字节码文件，换句话说，代理类和委托类的关系在运行前就决定了。</p>
<p>动态代理类的源码是在程序运行期间由JVM根据反射机制动态的生成，所以不存在代理类的字节码文件，代理类和委托类的关系是在程序运行时确定的。<br>更细节的东西请参考Spring AOP</p>
<h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p>浅拷贝不拷贝引用，深拷贝拷贝引用. 实现cloneable接口实现方法。<br>super.clone()浅拷贝，深拷贝需要拷贝对象，也可以通过序列化来进行深拷贝。刚刚写代码的时候发现cloneable接口很奇怪,没有任何方法,如果不实现会报错,调用的是Object的方法.Serializable接口也是标记接口.<br>从JVM的角度看，这就是一个标记接口而已。实现了就是打上cloneable标记，没实现就是没这个标记。然后到clone()的基本实现中，JVM会去检测要clone的对象的类有没有被打上这个标记，有就让clone，没有就抛异常。就这么简单。</p>
<p>我的git上有相关代码,再说一下cloneable是当初设计的一个flaw,那么该怎么实现比较好?不是很确定,也许用annotation吧,关于注解的代码git上也有个例子,不过等到某一天再详细写一下吧</p>
<h4 id="Servlet是线程安全的么？"><a href="#Servlet是线程安全的么？" class="headerlink" title="Servlet是线程安全的么？"></a>Servlet是线程安全的么？</h4><p>不是.实例变量(包括静态变量)的不正确使用是造成不安全的主要原因.<br>方法中的变量不会造成线程安全问题,避免的方法是尽量减少实例变量或者对方法加同步.</p>
<h4 id="创建一个对象的详细过程？其中发生了些什么？"><a href="#创建一个对象的详细过程？其中发生了些什么？" class="headerlink" title="创建一个对象的详细过程？其中发生了些什么？"></a>创建一个对象的详细过程？其中发生了些什么？</h4><p>先简单说一下:</p>
<ol>
<li>检测该类是否被加载(虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用)</li>
<li>如果没有JVM开始进行加载过程(验证/解析/初始化)</li>
<li>为新生对象分配内存</li>
<li>初始化0值,保证实力对象可以直接使用</li>
<li>设置必要值(hash码,GC算法,对象是哪个类的实例等)</li>
<li>执行init方法</li>
</ol>
<h4 id="多线程如何在多个CPU上分布-它们是如何保持同步的"><a href="#多线程如何在多个CPU上分布-它们是如何保持同步的" class="headerlink" title="多线程如何在多个CPU上分布? 它们是如何保持同步的?"></a>多线程如何在多个CPU上分布? 它们是如何保持同步的?</h4><p>这是我当时面试的时候遇到的一个问题,我查了一下,但是,目前并没有一个明确的答案,慢慢补充吧.</p>
<p>我们常用的JVM实现,HotSpot,他是采用1:1模型来实现Java线程的,也就是说一个Java线程是直接通过一个OS线程来实现的,中间并没有额外的间接结构.而且HotSpot自己不干涉线程的调度,全权交给底下的OS去处理.所以OS想把某个线程调度到某个CPU/核上,他自己就弄了.<br>“在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制”</p>
<p>当时有点蒙,现在看来,锁的是资源,并不是线程乱七八糟的cpu.多核又怎么样,资源的门关上了,当然可以实现安全.如果是集群,那么就用持久层来同步,就是这样.</p>
<p>后来又面了一个,发现我的回答是错的. 这次面试官说的很清楚,假设对象分布在多个JVM里,那怎么办?<br>我后来又问了一下,是个开放性问题:<br>我当时回答的是,使用版本号来控制,就像数据库乐观锁一样.<br>他又问,通过什么来判断这个版本号呢?我表示可以用zk当monitor.他说,中间件是吧.<br>我问他正确答案是什么,他表示,这是一个开放性问题. 也可以用中间件,比如说MQ来控制.</p>
<h4 id="线程调度算法有哪些？"><a href="#线程调度算法有哪些？" class="headerlink" title="线程调度算法有哪些？"></a>线程调度算法有哪些？</h4><ol>
<li>批处理中的调度算法<br> a.先来先服务 FCFS:非抢占式,进程按照他们请求CPU的顺序使用CPU,使用一个队列来管理. 缺点:对长作业有利(CPU密集有利).I/O处理时间很长,而这时CPU处于无事可做的等待.<br> b.最短作业优先 SJF:也属于非抢占式,之所以最短,肯定运行时间是可以预测的.长期运行对长作业不公平.<br> c.最短剩余时间优先:属于SJF的抢占式版本,如果新的进程比当前进程需要更少的时间,当前进程就被挂起.可以让后面的新的短作业获得良好服务.</li>
<li>交互系统中的调度<br> a.时间片轮转:系统将所有的就绪进程按照先来先服务算法排成一个队列,每次调度的时候,系统首先分给首进程一个时间片(操作系统给每条线程分配不同长度的时间片),当时间片用完时,由一个计时器发出时钟中断请求,调度程序根据这个请求终止该进程的运行并移到队尾.<br> b.优先级调度:根据优先级来运行,可以设置时间中断.<br> c.多级队列:最高优先级运行一个时间片,次高运行第二个.以此类推.<br> d.彩票调度: 随机调度,系统生成彩票,谁抢到谁用</li>
</ol>
<h4 id="在一个数组中，有若干个数，每个数字都出现两次，也就是说数组中如果出现了一个2，那必定存在另一个2，除了一个数仅仅出现了一次，如何在空间复杂度为O-1-的情况下找出这个数。"><a href="#在一个数组中，有若干个数，每个数字都出现两次，也就是说数组中如果出现了一个2，那必定存在另一个2，除了一个数仅仅出现了一次，如何在空间复杂度为O-1-的情况下找出这个数。" class="headerlink" title="在一个数组中，有若干个数，每个数字都出现两次，也就是说数组中如果出现了一个2，那必定存在另一个2，除了一个数仅仅出现了一次，如何在空间复杂度为O(1)的情况下找出这个数。"></a>在一个数组中，有若干个数，每个数字都出现两次，也就是说数组中如果出现了一个2，那必定存在另一个2，除了一个数仅仅出现了一次，如何在空间复杂度为O(1)的情况下找出这个数。</h4><p>两个相等的数异或是0,不相等的数异或是1,从头到尾异或剩下的就好了.</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>new<br>runnable (new之后调用start方法)<br>running(系统调度从runable到running)<br>stoped<br>block(获取锁失败)<br>wait(调用wait/join等方法)</p>
<h4 id="为什么内部类引用的外部变量必须是final的"><a href="#为什么内部类引用的外部变量必须是final的" class="headerlink" title="为什么内部类引用的外部变量必须是final的?"></a>为什么内部类引用的外部变量必须是final的?</h4><p>刚刚写了一个测试代码发现有报错,为什么会出现题目中的这个情况呢?<br>原因是内部类和外部类在JVM中处于同一级别,换句话说就是有不同的生命周期.如果外部类执行完被GC了,内部类还没执行完,就会出现引用失效,所以需要声明final而保证不被回收.</p>
<h4 id="线程安全的ArrayList"><a href="#线程安全的ArrayList" class="headerlink" title="线程安全的ArrayList?"></a>线程安全的ArrayList?</h4><p>首先说第一点vector被弃用了,效果太差.<br>我们可以使用Collections.synchronizedList(new ArrayList&lt;&gt;());<br>还有我们可以使用CopyOnWrite容器,比如CopyOnWriteArrayList.他适合多读少写的情况,缺点是不能保证实时一致性和占用空间.</p>
<h4 id="两条相交的单向链表，如何求他们的第一个公共节点"><a href="#两条相交的单向链表，如何求他们的第一个公共节点" class="headerlink" title="两条相交的单向链表，如何求他们的第一个公共节点"></a>两条相交的单向链表，如何求他们的第一个公共节点</h4><p>首先要知道,两个单向链表相交,他们的形状肯定是Y而不是X.<br>其次,如果相交,则最后一个节点相等.<br>好,我们先求出两个链表的长度,在长的先遍历Math.abs(La-Lb)个长度,然后两边一起遍历,相等的第一个节点就是所求节点</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>我其实一点都不懂NIO, 被问蒙了, 要看还是要看.</p>
<h4 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer!!!!!StringBuilder!!!!"></a>StringBuffer!!!!!StringBuilder!!!!</h4><p>竟然答错了,答错了…<br>StringBuffer是常用的对吧,他是线程安全的. StringBuilder是线程不安全的.</p>
<h3 id="JVM创建线程默认大小"><a href="#JVM创建线程默认大小" class="headerlink" title="JVM创建线程默认大小"></a>JVM创建线程默认大小</h3><p>我们知道每个线程都有一个栈，这个栈默认大小是多少？</p>
<p>百度了半天没找到，还是得stakOverflow. 一下就被我找到了，我当时竟然蒙对了。<br>You can use a VM option named ss to adjust the maximum stack size. A VM option is usually passed using -X{option}. So you can use java -Xss 1M to set the maximum of stack size to 1M.<br>Windows IA32 : 64 KB<br>Linux IA32 : 128 KB<br>Windows x86_64 : 128 KB<br>Linux x86_64 : 256 KB</p>
<h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>竟然错了…顺序记错了<br>正确的是<br>find 目录 -name stringPlatform</p>
<h4 id="Java-延迟加载"><a href="#Java-延迟加载" class="headerlink" title="Java 延迟加载"></a>Java 延迟加载</h4><p>延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。可以简单理解为，只有在使用的时候，才会发出sql语句进行查询。  </p>
<p>effective Java中写到: 就像大多数的优化方式一样,除非绝对必要,否则就不要这么做.<br>他降低了初始化类的开销,取提高了访问被延迟初始化类的开销.<br>根据延迟初始化与所需要的初始化比例,初始化这些域的开销,以及初始化这些域的次数,实际上延迟加载会降低效率.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField3</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> FieldHolder.field;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FieldType <span class="title">computeFieldValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FieldType();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="tomcat-classloader"><a href="#tomcat-classloader" class="headerlink" title="tomcat classloader"></a>tomcat classloader</h4><p>以前知道这个知识点,最近面试的时候问完JVM的classloader之后被问到了tomcat的classloader, 蒙了. 在这先过一下吧!<br>在网上找了一下，讲清楚的不是很多，还是得stackoverflow.<br><a href="https://stackoverflow.com/questions/19559210/just-how-tomcat-classloader-separate-different-webapps-object-scope-in-same-jvm" target="_blank" rel="external">https://stackoverflow.com/questions/19559210/just-how-tomcat-classloader-separate-different-webapps-object-scope-in-same-jvm</a></p>
<p>As we know tomcat can load more than one webapp at once, and those webapps can work separate, and do not disturb each other, and they work in same JVM.</p>
<p>这个问题就直接给了一个很明白的回答, 为什么tomcat要实现自己的classloader.我们可以自己尝试一下定一个java.lang.Object 会发现是无法被加载的,为什么呢? 因为JVM的双亲委托模型,classloader加载类都要往上层去找,找到了bootstrap,一看, 有Object,那就bootstrap来加载. 如果tomcat也按照这个逻辑来进行,那么就会出现不同web app之间的干扰了.</p>
<p>Remember that a class in Java in identified by its full qulified name and class loader that load it. Tomcat use seprate classloadrs for each context(web application) that you deploy,thus keeping them seperate. In addition, the system classloader loads the tomcat sepcific libraries and JVM bootstrap loader load the Java Core libraries.</p>
<h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/08/24/知识点/" class="archive-article-date">
  	<time datetime="2017-08-24T06:08:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-08-24</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/知识点/">知识点</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2017/08/22/锁/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java中的锁</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="知识点" data-title="知识点" data-url="http://tiltcat.com/2017/08/24/知识点/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 tiltcat
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/CAS/" style="font-size: 10px;">CAS</a> <a href="/tags/Concurrent/" style="font-size: 15px;">Concurrent</a> <a href="/tags/Concurrent-HashMap/" style="font-size: 10px;">Concurrent HashMap</a> <a href="/tags/Design-Pattern/" style="font-size: 10px;">Design Pattern</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/IoC/" style="font-size: 10px;">IoC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Lock/" style="font-size: 10px;">Lock</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 10px;">Netty</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/事务管理/" style="font-size: 15px;">事务管理</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/发布-订阅系统/" style="font-size: 10px;">发布-订阅系统</a> <a href="/tags/数据类型/" style="font-size: 10px;">数据类型</a> <a href="/tags/知识点/" style="font-size: 10px;">知识点</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;br&gt;大家好，我叫周克，独生子女&lt;br&gt;名字是我出生的时候二大爷起的 &lt;br&gt;没有固定职业，偶尔打零工&lt;br&gt;爱好篮球和火锅&lt;br&gt;没什么理想，平时也不爱想，嫌累&lt;br&gt;总体上来说就是：胸无大志，混吃等死&lt;br&gt;以上都是我瞎编的 &lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>