<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://tiltcat.com">
  <title>设计模式 | Let&#39;s do this</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="设计模式分为三种类型，共23种：   创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。">
<meta name="keywords" content="Design Pattern">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://tiltcat.com/2017/01/20/设计模式/index.html">
<meta property="og:site_name" content="Let&#39;s do this">
<meta property="og:description" content="设计模式分为三种类型，共23种：   创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/Builder%20pattern.jpg">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/%E8%A7%82%E5%AF%9F%E8%80%85.png">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="http://ogeojkg3t.bkt.clouddn.com/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F.png">
<meta property="og:updated_time" content="2017-02-15T10:12:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式">
<meta name="twitter:description" content="设计模式分为三种类型，共23种：   创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。">
<meta name="twitter:image" content="http://ogeojkg3t.bkt.clouddn.com/Builder%20pattern.jpg">
  
  
    <link rel="icon" href="/images/favicon.jpg">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">tiltcat</a></h1>
		</hgroup>

		
		<p class="header-subtitle">wub lab dup dup</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/felisnigreps" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/cool5231" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tilt-play" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">tiltcat</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/images/avatar.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">tiltcat</h1>
			</hgroup>
			
			<p class="header-subtitle">wub lab dup dup</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/felisnigreps" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/cool5231" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/tilt-play" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>设计模式分为三种类型，共23种：</p>
<blockquote>
<ul>
<li>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li>
<li>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>在详细探讨设计模式之前，我们先说下基本的设计模式规则：</p>
<h3 id="单一模式原则"><a href="#单一模式原则" class="headerlink" title="单一模式原则"></a>单一模式原则</h3><p>每个类都只应该负责单一的功能，切忌在一个类中插入太多功能。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>一个子类可以替换掉父类并且正常工作。（简单来说就是不应该让子类覆盖父类的方法，听起来有些不对，是么？ 当然，应用这个模式需要你进一步的思考，当你覆盖了父类的方法，是不是可以完成现在的工作？）</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>也称作接口最小化原则，一个接口里的方法应该尽可能的少。不然就会出现接口里的某些方法是空着的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mobile</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;<span class="comment">//手机可以打电话</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>;<span class="comment">//手机可以发短信</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBird</span><span class="params">()</span></span>;<span class="comment">//手机可以玩愤怒的小鸟？</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的第三个方法就明显不合适，因为有些手机是没办法玩愤怒的小鸟的，这样会强迫某些类来实现这个方法，但是用户调用了又得不到合适的结果。我们可以这样做<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Mobile</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playBird</span><span class="params">()</span></span>;<span class="comment">//智能手机的接口就可以加入这个方法了</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>高层模块不应该依赖于底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>解释一下依赖倒置，比如说我们现在想要吃烤肉，那么我们会写一个eat()，然后传递烤肉。这是自然语言中的面向实现，我们需要什么，我们就做什么，在这个例子里，我们依赖的是烤肉。但是如果你想吃别的东西呢？这样就需要你去修改eat()的具体代码了。<br>可以吃的东西多种多样，会对扩展造成很大的困难。</p>
<p>刚才是依赖烤肉，那么如果依赖倒置了是什么样子呢？ 我们不依赖实现了（烤肉），而是依赖抽象（可以吃的东西），那么我们只要声明一个接口，然后让烤肉去继承他就行了。实现了由依赖实现到依赖抽象的依赖倒置。</p>
<h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p>也称最小知道原则（单一职责原则），一个类需要尽可能小的依赖其他类的细节，这样做是为了降低耦合度。高内聚代表的是一个类应该尽量封装他自己的细节，把所有逻辑在自己内部处理。这个原则也和我们所提倡的高内聚低耦合相呼应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String path;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> BufferedReader br;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(String path)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.path = path;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBufferedReader</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</div><div class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(path)));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException, IOException</span>&#123;</div><div class="line">        a = Integer.valueOf(br.readLine());</div><div class="line">        b = Integer.valueOf(br.readLine());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类这么写是非常不好的，首先我们看到了很多的public，这样就代表暴露了太多的细节给外部，如果我们要调用，那么会这么写：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Reader reader = <span class="keyword">new</span> Reader(<span class="string">"E:/test.txt"</span>);</div><div class="line">        reader.setBufferedReader();</div><div class="line">        reader.readLine();</div><div class="line">        <span class="keyword">int</span> a = reader.getA();</div><div class="line">        <span class="keyword">int</span> b = reader.getB();</div><div class="line">        <span class="comment">//以下用于计算等等</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出暴露了太多的信息用于交互，我们可以这么修改：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    <span class="keyword">private</span> String path;</div><div class="line">    <span class="keyword">private</span> BufferedReader br;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.path = path;</div><div class="line">        setBufferedReader();</div><div class="line">        readLine();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//注意，我们变为私有的方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBufferedReader</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</div><div class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//注意，我们变为私有的方法</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException, IOException</span>&#123;</div><div class="line">        a = Integer.valueOf(br.readLine());</div><div class="line">        b = Integer.valueOf(br.readLine());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>对修改关闭，对扩展开放。</p>
<p>这是我们的理想状态，但是实现起来非常困难，这个原则更像是上面原则的一个总结，需要我们在代码中慢慢的去体会和实现。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>说了很多次的单例模式，很多种写法,两种可以用的，一个双重加锁。一个泛型。</p>
<p>当系统需要只有一个对象来处理问题的时候可以使用此模式，什么打印机啊之类的，或者线程池什么的。好处是处理简单，节省资源。缺点也有很多，比如说有点违反单一原则，他可能即是工厂，又处理业务逻辑。总之呢，具体情况，具体分析.</p>
<p>简单来说，这些类在系统的的同一时刻只能有一种状态。然后就没什么可说的了，看看<a href="https://github.com/felisnigreps/DesignPattern" target="_blank" rel="external">代码</a>吧.</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>所谓代理就是在某些情况下，无法直接调用对象或者调用对象的功能不满足需求。一个对象代替另一个对象行使功能</p>
<p>代理分为两种，静态代理和动态代理，静态代理是在编译期对字节码进行修改，然后达到我们的需求，而动态代理是在运行过程中进行更改。<br>我们再<a href="http://tiltcat.com/2016/10/27/SpringAOP/">Spring AOP</a>里已经谈过了这两种代理，可以参考下。</p>
<p>静态代理就是继承一样的接口，然后添加业务逻辑，调用代理类。<br>动态代理就是继承InvocationHandler,然后调用invoke方法。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</p>
<p>这个模式的主要特点就是可以实现克隆，首先说，优点是资源消耗比较小，那么，使用场景是什么呢？</p>
<blockquote>
<ul>
<li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li>
</ul>
</blockquote>
<p>比如说周报，可以使用克隆来创建一个模板。</p>
<p>克隆又分深克隆和浅克隆。深克隆克隆引用对象，浅克隆则使用同一个引用对象。</p>
<p>使用Java自带的Cloneable可以直接实现克隆，深克隆还需要实现Serializable接口。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>工厂模式即为类的创建模式，又叫静态工厂方法，通过工厂来创建各种各样不同类的实例。</p>
<p>比如说用户登录有多种方式，这时候工厂类就可以通过类型来生成不同的对象来处理业务逻辑。从而也实现了责任的分割，便于修改和扩展。写点伪代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Login</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginByMobile</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</div><div class="line">        .....</div><div class="line">        业务逻辑</div><div class="line">        ......</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginByEmail</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</div><div class="line">        .....</div><div class="line">        业务逻辑</div><div class="line">        ......</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Login <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (email) &#123;</div><div class="line">            业务逻辑</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoginByEmail();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mobile) &#123;</div><div class="line">            业务逻辑</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoginByEmail();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            异常处理</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果不使用简单工厂代理，那么所有的业务逻辑就要写在一块，不但耦合度高，而且会出现重复代码。有兴趣的童鞋可以试一试。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>和刚提到的简单工厂方法有关系，简单工厂方法是把判断的业务逻辑放到一个类中。但是如果这个逻辑过多，判断过于复杂，那么工厂方法就并不适用了。这个时候我们需要声明一个工厂接口，其他的工厂类要实现这个接口，来完成他们的功能，其实本人感觉就是把类换成接口，在职责分担的前提下进一步抽象，实现高内聚低耦合。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>工厂模式上的一个延伸，当每个工厂至少维护两种产品，但是每个工厂又有很多共同的抽象的时候，需要使用此模式。</p>
<p>此模式需要维护产品等级和产品族。简单来说，你想去打猎，需要购买枪和子弹，但是枪只能用固定的子弹。按照工厂模式，比如说有两个工厂，一个生产AK和AK子弹，一个生产13（沙鹰，CS我用的最好的枪，关键在于点射爆头）和13的子弹,那么如果用户买了AK和13的子弹，打猎遇到野猪，卒。</p>
<p>这样肯定是不合适的，需要有人来和他说：少年，你这智商欠费啊。才能避免此类段子发生呢？但是工厂模式是不不会维护这种关系的，那么该怎么办呢？用户说，我要买AK打猎，就完事了，不用你选子弹，我们按照产品族给你拿子弹。问题解决了。</p>
<p>一个抽象工厂接口，各个工厂类实现。调用的时候面向抽象，用户直接传入需要的对象(枪)，工厂类就会生成相关产品族。</p>
<p>当一个系统有多个产品族，但是消费者每次只消费其中一个产品族，那么应该使用抽象工厂。缺点是如果要在产品族中添加新的产品，那么需要修改所有的工厂。</p>
<h2 id="建造模式"><a href="#建造模式" class="headerlink" title="建造模式"></a>建造模式</h2><p>看到这模式我一下想起来Netty的AbstractBootstrap了，因为有太多的参数，而且情况较多，所以写各种各样的构造方法很不合适，不过那个是builder方法，而不是我们要说的建造模式（虽然有点像），那么建造模式是什么，好在哪，怎么用，就是我们下面要说明的。</p>
<p>生活中有一些很复杂的对象，比如说火箭。我想要一个火箭对象，里面有几百万个零件，那么我想要火箭的对象时，我没必要了解所有的零件是什么，都有什么作用。需要有一个关系来帮我维持这种关系，那么维持这种关系的就叫做建造者，这个模式就是建造模式。<br>（火箭理解起来不好的话尝试变为汽车）</p>
<p>建造者模式：把一个复杂对象的建造和表现进行分离，使得同样的构建过程可以创建不同的表示。（精辟！）又叫生成器模式。</p>
<p>在客户端代码中，用户无需考虑具体的构建过程，只需提供需要构建的类型，那么建造者就会根据用户提供的参数来建造响应的对象，建造者可以通过同样的构建过程来创建不同的对象。</p>
<p><img src="http://ogeojkg3t.bkt.clouddn.com/Builder%20pattern.jpg" alt=""></p>
<p>Director：指挥者<br>Builder:抽象建造者<br>ConcreteBuilder: 具体建造者<br>Product:产品</p>
<p>这里要注意可以有多个具体的建造者，而且每个具体的建造者都是分离的，这也是低耦合的表现，方便我们尽享替换和改装，而且其中的建造方法可以继续进行细分。</p>
<p>如果系统中只有一个具体建造者，那么可以省略抽象建造者。</p>
<blockquote>
<ul>
<li>与抽象工厂模式相比，抽象工厂生产一系列相关的产品，这些产品位于不不同的产品层级，从而形成了一个产品族。 而建造者模式返回一个完整的产品。</li>
</ul>
</blockquote>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>这个模式现在才记，不过已经比较熟悉了，当一个对象的状态改变的时候需要通知另一个或者几个对象的时候，那么就可以使用观察者模式。比如说公告板呀，广播电视啊什么的，所以也叫发布-订阅模式。</p>
<p>前几天看一个文章，说是华尔街某公司的大厅里挂着川普的twitter的直播，一旦有更新，直接响警报。</p>
<p>所以说在这里，床破就是发布者，而华尔街的公司，就是订阅者了。</p>
<p><img src="http://ogeojkg3t.bkt.clouddn.com/%E8%A7%82%E5%AF%9F%E8%80%85.png" alt=""></p>
<p>看看UML图，抽象主题/抽象观察者和他们的具体实现。</p>
<p>github上有关于这块的代码，参考一下就好。</p>
<p>Java对观察者模式的支持有Observer接口和Observable类。至于怎么用有机会再具体展开。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>按照自己的理解简单先说一下，是把算法的实现和算法的定义分割开来，实现低耦合和开闭原则。</p>
<blockquote>
<ul>
<li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。<br>*在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</li>
<li>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li>
<li>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</li>
<li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。</li>
</ul>
</blockquote>
<p><img src="http://ogeojkg3t.bkt.clouddn.com/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>第一次写这个模式的时候我自己都没怎么明白，虽然写的都对（因为大部分都是在网上抄的）</p>
<p>我自己也要写代码操作一下,拿游戏举例子，不知道大家玩没玩过War3 RPG,比如说小兵的故事。开局我们可以选三个技能。现在要设计两个小兵，假设备选技能有五种（烈焰风暴 致命一击 献祭 妖术 分裂攻击）</p>
<p>好了，我们现在开始设计两个小兵，每个小兵有三个技能，可以攻击和移动。<br>第一个想法是，好办，先设计一个超类，然后小兵A，B各自实现就好了。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"攻击"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"移动"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">skillA</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">skillB</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">skillC</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Soldier</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skillA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"烈焰风暴"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skillB</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"妖术"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skillC</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"献祭"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Soldier</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skillA</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"烈焰风暴"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skillB</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"分裂攻击"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skillC</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"献祭"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写好了，不过发现有大量的冗余代码，如果要新建100个小兵，那可咋整？</p>
<p>那我们能不能把技能做成抽象化,然后让各个小兵去实现？可以是可以，不过效果并不好，接口并不能实现代码复用，因为实现的类还需要自己写。这时候我们策略模式的思想就体现出来了，面向抽象编程，不面向实现编程，这个该怎么写呢？</p>
<p>这边代码贴切来比较繁琐，请参见我的github。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>比如我们的电脑电源是三相插头，但是插线板是两个口，那么三转二插头就是适配器。</p>
<p>适配器模式是把一个接口转换成用户可以使用的接口，使得不兼容的类可以一起工作。适配器有两种，类的适配器模式和对象的适配器模式。</p>
<p>我们有三个角色，源，目标，适配器。</p>
<p>假设我们目标有a(),b(),源有a(),那么适配器就要实现b()来进行适配。</p>
<p>因为是适配器继承了源，所以这个是类适配器模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//类适配器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对象适配器</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Adaptee adaptee;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee.a();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//直接补充方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//写相关的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为需要继承，但是Java是单继承，所以有些时候情况会变得很尴尬。</p>
<h3 id="默认适配器模式-Default-Adapter-Pattern-或缺省适配器模式"><a href="#默认适配器模式-Default-Adapter-Pattern-或缺省适配器模式" class="headerlink" title="默认适配器模式(Default Adapter Pattern)或缺省适配器模式"></a>默认适配器模式(Default Adapter Pattern)或缺省适配器模式</h3><blockquote>
<ul>
<li><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</p>
</li>
<li><p>结构型模式描述如何将类或者对象结合在一起形成更大的结构。<br>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
</li>
<li>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li>
<li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li>
<li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。<br>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li>
</ul>
</blockquote>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将请求封装为对象，通过这种方式可以更好的实现拓展，也就是更好的实现了solid原则。</p>
<p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p>
<p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p>
<blockquote>
<ul>
<li>电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。显然，电视机遥控器就是一个典型的命令模式应用实例。</li>
</ul>
</blockquote>
<p><img src="http://ogeojkg3t.bkt.clouddn.com/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p><img src="http://ogeojkg3t.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>第一感觉有点像适配器模式，但是还不一样。</p>
<p>装饰就像是往本体上加特性和功能。比如说孙悟空，本来的功能没有用腮呼吸（假设），但是如果他变成鱼，那么就有这么个功能了。所以鱼的具体实现类就装饰了孙悟空。</p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>也称作门面模式，先看图:<br><img src="http://ogeojkg3t.bkt.clouddn.com/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.jpg" alt=""></p>
<p>比如说你去医院，需要挂号，化验，取药等等一系列操作。</p>
<p>所谓门面模式就是提供了一个接口来做这些事情，比如说一个接待员，你去了只需要把你的信息告诉接待员，然后她就会走完所有流程然后把结果交给你。（例子倒不是很恰当，这边姑且理解一下）</p>
<p>而且他还可以屏蔽内部类，保证安全性，比如病人如果要去化验室，就有可能接触到其他病人的病例然后做手脚。</p>
<p>Tomcat中对门面模式也有应用，<a href="http://www.cnblogs.com/java-my-life/archive/2012/05/02/2478101.html" target="_blank" rel="external">可以参考这里</a>.</p>
<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>这个模式比较好理解，比如说总设计师给出总体方案，这就是一个模板，然后由各个设计师来实现具体方案。</p>
<p>啊，这不由得让我想起了1979年，那是一个春天，一位老人在南海画了一个圈…有点跑题，不过这个总体思路是没问题的。</p>
<p>再举个例子，银行有两个贷款业务，利息是不一样的，总的设计就是，判断业务类别，然后算出利息。细节设计就是两个实现类来实现不同的业务细节。</p>
<p>！<a href="http://ogeojkg3t.bkt.clouddn.com/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F.png" target="_blank" rel="external"></a></p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>用一句话来表述，状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式的示意性类图如下所示：</p>
<p><img src="http://ogeojkg3t.bkt.clouddn.com/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p>
<h2 id="合成模式"><a href="#合成模式" class="headerlink" title="合成模式"></a>合成模式</h2><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>是对象的结构模式，使得抽象化和实体化可以脱耦，使得两者可以独立的变化。</p>
<p>比如你一个负责画图形的类，每个图形又有各种颜色。比如圆形/正方形，红色/黑色。有一种设计师每一个图形都对应两个颜色，但这显然不够好，这时候就可以使用桥接模式，也称为柄体模式或者接口模式。</p>
<p>引用Java与模式中的话：</p>
<p>脱耦合市值将抽象化和实现化之间的耦合解脱开，或者说是将强关联变为弱关联。<br>所谓强关联，是在编译期确定的，无法在运行时期改变的关联。所谓弱关联，就是在编译期可以动态确定并改变的关联。</p>
<p>将两个角色的继承关系变为聚合关系，就是将强关联改变为弱关联。所以桥接模式的作用就是在一个软件系统中将继承关系改变为组合/聚合关系。</p>
<p><img src="http://ogeojkg3t.bkt.clouddn.com/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>桥梁模式涉及的角色有：</p>
<blockquote>
<ul>
<li>抽象化角色：抽象化的定义，并拥有实现化角色的一个实例。</li>
<li>修正抽象化角色：抽象化角色的继承，改变和修正父类对抽象化的定义。</li>
<li>实现化角色：这个角色给出实现化角色的接口，但不给出具体的实现</li>
<li>具体实现化角色：给出实现化角色的具体实现。</li>
</ul>
</blockquote>
<p>桥梁模式看了一堆，现在终于有所理解了，这博文写的好：<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/20/设计模式/" class="archive-article-date">
  	<time datetime="2017-01-20T07:27:48.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-20</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Design-Pattern/">Design Pattern</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2017/02/16/SpringIOC/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          Spring IOC
        
      </div>
    </a>
  
  
    <a href="/2017/01/18/Collection家族/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Collection家族</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="设计模式" data-title="设计模式" data-url="http://tiltcat.com/2017/01/20/设计模式/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 tiltcat
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/CAS/" style="font-size: 10px;">CAS</a> <a href="/tags/Concurrent/" style="font-size: 16.67px;">Concurrent</a> <a href="/tags/Design-Pattern/" style="font-size: 10px;">Design Pattern</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Http/" style="font-size: 10px;">Http</a> <a href="/tags/IO/" style="font-size: 10px;">IO</a> <a href="/tags/IoC/" style="font-size: 10px;">IoC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 10px;">Netty</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/事务管理/" style="font-size: 13.33px;">事务管理</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/发布-订阅-系统/" style="font-size: 10px;">发布-订阅 系统</a> <a href="/tags/数据类型/" style="font-size: 10px;">数据类型</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;br&gt;大家好，我叫周克，独生子女&lt;br&gt;名字是我出生的时候二大爷起的 &lt;br&gt;没有固定职业，偶尔打零工&lt;br&gt;爱好篮球和火锅&lt;br&gt;没什么理想，平时也不爱想，嫌累&lt;br&gt;总体上来说就是：胸无大志，混吃等死&lt;br&gt;以上都是我瞎编的 &lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>